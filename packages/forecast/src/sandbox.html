<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .legend-container {
            position: absolute;
            bottom: 20px;
            right: 60px;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            display: none;
            /* Hidden by default, shown via JS */
            font-family: Arial, sans-serif;
            font-size: 12px;
            z-index: 1000;
        }

        .legend-titlebar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .legend-title {
            font-weight: bold;
            font-size: 14px;
        }

        .legend-source {
            color: #666;
            font-size: 10px;
        }

        .legend-gradient {
            height: 15px;
            /* Split gradient to show the two distinct categories */
            background: linear-gradient(to right, #00BFFF 40%, #ff0000 60%);
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div class="legend-container" id="legendContainer">
        <div class="legend-titlebar">
            <span class="legend-title">FLOOD DETECTION</span>
            <span class="legend-source">NASA MODIS • 2-Day</span>
        </div>
        <div class="legend-gradient"></div>
        <div class="legend-labels">
            <span>Normal Water</span>
            <span>Flood Detected</span>
        </div>
    </div>
    <script>
        let map;

        function initMap() {
            map = new google.maps.Map(document.getElementById("map"), {
                center: { lat: -1.2921, lng: 36.8219 }, // Nairobi
                zoom: 7,
                disableDefaultUI: true,
                zoomControl: true,
                mapTypeId: 'terrain',
                mapId: "DEMO_MAP_ID"
            });

            google.maps.event.addListener(map, 'idle', () => {
                window.parent.postMessage({ type: 'MAP_IDLE' }, '*');
            });

            const geocoder = new google.maps.Geocoder();
            let currentTileLayer = null;

            // Refresh function to reload the current layer (triggering new getTile calls)
            const refreshLayer = () => {
                if (currentTileLayer) {
                    // Force a reload by removing and re-adding
                    const index = map.overlayMapTypes.length - 1;
                    if (index >= 0) {
                        const layer = map.overlayMapTypes.getAt(index);
                        map.overlayMapTypes.removeAt(index);
                        map.overlayMapTypes.push(layer);
                    }
                }
            };

            const snapTo8Day = (date) => {
                const start = new Date(date.getFullYear(), 0, 1);
                const diff = date - start;
                const oneDay = 1000 * 60 * 60 * 24;
                const dayOfYear = Math.floor(diff / oneDay);
                const snappedDOY = (dayOfYear) - (dayOfYear % 8);
                const snappedDate = new Date(date.getFullYear(), 0, 1 + snappedDOY);
                return snappedDate.toISOString().split('T')[0];
            };

            // Canvas Filter: Removes non-water pixels from Satellite Imagery
            class FilteredMapType {
                constructor(tileSize, layerConfig, dateStr) {
                    this.tileSize = tileSize;
                    this.config = layerConfig;
                    this.dateStr = dateStr;
                    this.name = 'Filtered Layer';
                }

                getTile(coord, zoom, ownerDocument) {
                    const div = ownerDocument.createElement('div');
                    div.style.width = this.tileSize.width + 'px';
                    div.style.height = this.tileSize.height + 'px';

                    const canvas = ownerDocument.createElement('canvas');
                    canvas.width = this.tileSize.width;
                    canvas.height = this.tileSize.height;
                    div.appendChild(canvas);

                    const ctx = canvas.getContext('2d');

                    const img = new Image();
                    img.crossOrigin = "Anonymous";

                    // OVERZOOM LOGIC
                    const maxZoom = this.config.zoom; // e.g. 9
                    const isOverzoomed = zoom > maxZoom;

                    let srcZoom = zoom;
                    let srcX = coord.x;
                    let srcY = coord.y;
                    let srcSize = this.tileSize.width; // 256
                    let offsetX = 0;
                    let offsetY = 0;
                    let drawSize = this.tileSize.width;

                    if (isOverzoomed) {
                        srcZoom = maxZoom;
                        const zoomDiff = zoom - maxZoom;
                        const factor = Math.pow(2, zoomDiff);

                        // Calculate ancestor tile
                        srcX = Math.floor(coord.x / factor);
                        srcY = Math.floor(coord.y / factor);

                        // Calculate subsection
                        // (coord.x % factor) gives position index within the ancestor
                        offsetX = (coord.x % factor) * (this.tileSize.width / factor);
                        offsetY = (coord.y % factor) * (this.tileSize.height / factor);

                        // Width/Height of the subsection in the source image
                        drawSize = this.tileSize.width / factor;
                    }

                    // Fetch from GIBS (Always at supported zoom level)
                    const url = `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/${this.config.name}/default/${this.dateStr}/GoogleMapsCompatible_Level${this.config.zoom}/${srcZoom}/${srcY}/${srcX}.${this.config.format}`;

                    img.src = url;

                    img.onload = () => {
                        // Draw interpolated scale (Smooths 'jaggies')
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, offsetX, offsetY, drawSize, drawSize, 0, 0, canvas.width, canvas.height);


                        // PIXEL FILTERING LOGIC
                        if (this.config.isWaterLayer) {
                            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imgData.data;

                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];

                                // NASA L3 Flood Color Key:
                                // Surface Water: Blue (approx R:0-100, G:0-100, B:150-255)
                                // Recurring Water: Cyan
                                // Land/Cloud: Grey/White/Brown

                                // Filter: If it's NOT Blue-ish, make transparent
                                // High Blue channel relative to Red/Green is a good heuristic

                                // Re-Coloring for High Contrast (GIS Style)
                                // Re-Coloring for High Contrast (GIS Style)
                                // Using channel differentials to create "Tiers" from the anti-aliased source data

                                const redIntensity = r - Math.max(g, b);
                                const blueIntensity = b - Math.max(r, g);

                                // TIER 1: FLOOD (Red Dominant)
                                if (redIntensity > 50) {
                                    if (redIntensity > 100) {
                                        // EXTREME DANGER (Deep Red)
                                        data[i] = 200; data[i + 1] = 0; data[i + 2] = 0; data[i + 3] = 255;
                                    } else {
                                        // HIGH DANGER (Orange-Red)
                                        data[i] = 255; data[i + 1] = 69; data[i + 2] = 0; data[i + 3] = 255;
                                    }
                                }
                                // TIER 2: TRANSITION / IMMINENT (Mixed/Weak Signals)
                                else if (r > 150 && g > 100 && b < 100) {
                                    // MODERATE / WATCH (Yellow)
                                    data[i] = 255; data[i + 1] = 200; data[i + 2] = 0; data[i + 3] = 200;
                                }
                                // TIER 3: NORMAL WATER (Blue Dominant)
                                else if (blueIntensity > 10) {
                                    data[i] = 0;       // R
                                    data[i + 1] = 100;   // G
                                    data[i + 2] = 255;   // B
                                    data[i + 3] = 150;   // Alpha (0.6)
                                }
                                else {
                                    // LAND/CLOUD: Transparent
                                    data[i + 3] = 0;
                                }
                            }
                            ctx.putImageData(imgData, 0, 0);
                        }
                    };

                    return div;
                }
            }

            // Helper: Get Layer
            const getGibsLayer = (layerId) => {
                const today = new Date();
                let config = null;
                let dateStr = "";

                if (layerId === 'VEGETATION') {
                    today.setDate(today.getDate() - 16);
                    dateStr = snapTo8Day(today);
                    config = { name: 'MODIS_Terra_NDVI_8Day', zoom: 9, format: 'png', opacity: 0.6 };
                    // NDVI has its own color map, usually fine as is.
                    // Return standard ImageMapType for speed if no filtering needed.
                    return new google.maps.ImageMapType({
                        getTileUrl: function (coord, zoom) {
                            return `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/${config.name}/default/${dateStr}/GoogleMapsCompatible_Level${config.zoom}/${zoom}/${coord.y}/${coord.x}.${config.format}`;
                        },
                        tileSize: new google.maps.Size(256, 256), opacity: 0.6
                    });

                } else if (layerId === 'HEAT') {
                    // NASA VIIRS City Lights (Static, Cloud-Free)
                    // Best for visualizing Urbanization / Built-up areas
                    // Uses 2012 baseline which is the standard cloud-free night lights product
                    dateStr = '2012-01-01';
                    config = { name: 'VIIRS_CityLights_2012', zoom: 8, format: 'jpg', opacity: 0.6 };

                    // Add CSS to boost contrast of night lights
                    const style = document.createElement('style');
                    style.innerHTML = `img[src*="VIIRS_CityLights_2012"] { filter: brightness(1.3) contrast(1.5) saturate(1.2); }`;
                    document.head.appendChild(style);

                    return {
                        tileSize: new google.maps.Size(256, 256),
                        maxZoom: 12, // Allow zooming deeper
                        name: 'URBANIZATION',
                        getTile: function (coord, zoom, ownerDocument) {
                            const div = ownerDocument.createElement('div');
                            div.style.width = '256px';
                            div.style.height = '256px';
                            div.style.overflow = 'hidden';
                            div.style.position = 'relative';
                            div.style.opacity = '0.6'; // Maintain requested transparency

                            const img = ownerDocument.createElement('img');
                            // Apply the contrast/brightness filter we defined in CSS
                            // Note: CSS selector targets src string, so this still works or we add class
                            img.style.position = 'absolute';

                            // Max native zoom for this layer is 8
                            const maxNativeZoom = 8;

                            if (zoom <= maxNativeZoom) {
                                // Direct load
                                img.src = `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/${config.name}/default/${dateStr}/GoogleMapsCompatible_Level${config.zoom}/${zoom}/${coord.y}/${coord.x}.${config.format}`;
                                img.style.width = '256px';
                                img.style.height = '256px';
                            } else {
                                // Overzoom Logic (CSS Scaling)
                                const scale = Math.pow(2, zoom - maxNativeZoom);
                                const x = Math.floor(coord.x / scale);
                                const y = Math.floor(coord.y / scale);

                                img.src = `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/${config.name}/default/${dateStr}/GoogleMapsCompatible_Level${config.zoom}/${maxNativeZoom}/${y}/${x}.${config.format}`;

                                // Scale up the image
                                const dim = 256 * scale;
                                img.style.width = `${dim}px`;
                                img.style.height = `${dim}px`;

                                // Position it to show the correct portion
                                const offsetX = (coord.x % scale) * 256;
                                const offsetY = (coord.y % scale) * 256;
                                img.style.left = `-${offsetX}px`;
                                img.style.top = `-${offsetY}px`;
                            }

                            div.appendChild(img);
                            return div;
                        }
                    };

                } else if (layerId === 'AIR') {
                    // *** GOOGLE AIR QUALITY HEATMAP API ***
                    return new google.maps.ImageMapType({
                        getTileUrl: function (coord, zoom) {
                            // Testing with US_AQI to diagnose issue
                            return `https://airquality.googleapis.com/v1/mapTypes/US_AQI/heatmapTiles/${zoom}/${coord.x}/${coord.y}?key=${CONFIG.GOOGLE_MAPS_API_KEY}`;
                        },
                        tileSize: new google.maps.Size(256, 256),
                        opacity: 0.7,
                        name: 'PM2.5 Air Quality'
                    });


                } else if (layerId === 'WATER') {
                    // SMAP L4 Root Zone Soil Moisture (Model Value-Added)
                    // SYSTEM CLOCK FIX: Environment reports 2025, but live data is 2024.
                    // Dynamic Logic: Use Today (System) adjusted to 2024, minus 7 day latency.
                    const waterDate = new Date();
                    if (waterDate.getFullYear() > 2024) waterDate.setFullYear(2024);
                    waterDate.setDate(waterDate.getDate() - 7);
                    dateStr = waterDate.toISOString().split('T')[0];
                    console.log("Loading Water Data for:", dateStr);
                    config = { name: 'SMAP_L4_Analyzed_Root_Zone_Soil_Moisture', zoom: 6, format: 'png', opacity: 0.7 };

                    return {
                        tileSize: new google.maps.Size(256, 256),
                        maxZoom: 12,
                        name: 'SOIL MOISTURE',
                        getTile: function (coord, zoom, ownerDocument) {
                            const canvas = ownerDocument.createElement('canvas');
                            canvas.width = 256;
                            canvas.height = 256;
                            canvas.style.opacity = '0.9'; // Increased opacity for Hydro Highlight

                            // SEAM FIX: Slight overlap to hide grid lines between tiles
                            // Reduced from 1.01 to 1.002 to improve geometric accuracy (only 0.5px expansion)
                            canvas.style.transform = 'scale(1.002)';

                            const ctx = canvas.getContext('2d');
                            ctx.imageSmoothingEnabled = true;
                            ctx.imageSmoothingQuality = 'high';

                            // HELPER: Hydro-Highlight Filter
                            // Enhances blue/green "wet" pixels and suppresses brown/yellow "dry" pixels
                            const enhanceWaterZones = (ctx) => {
                                const imgData = ctx.getImageData(0, 0, 256, 256);
                                const data = imgData.data;
                                for (let i = 0; i < data.length; i += 4) {
                                    const r = data[i];
                                    const g = data[i + 1];
                                    const b = data[i + 2];

                                    // SMAP Palette Analysis:
                                    // Wet = Blue Dominant OR Green Dominant
                                    // Dry = Red Dominant (Brown/Yellow)

                                    const isWet = (b > r) || (g > r);

                                    if (isWet) {
                                        // WET ZONES: Make vibrant Blue/Cyan
                                        // Boost Blue channel to satisfy "more blue" request
                                        data[i] = r * 0.6;          // Reduce Red
                                        data[i + 1] = g;              // Keep Green
                                        data[i + 2] = Math.max(b, 180); // Min Blue brightness
                                        data[i + 3] = 220;            // High Opacity
                                    } else {
                                        // DRY ZONES: Fade out to emphasize water
                                        data[i + 3] = 60;             // Low Opacity (Transparent)
                                    }
                                }
                                ctx.putImageData(imgData, 0, 0);
                            };

                            const maxNativeZoom = 6;

                            if (zoom <= maxNativeZoom) {
                                // Direct load
                                const img = new Image();
                                img.crossOrigin = "Anonymous";
                                img.src = `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/${config.name}/default/${dateStr}/GoogleMapsCompatible_Level${config.zoom}/${zoom}/${coord.y}/${coord.x}.${config.format}`;

                                img.onload = function () {
                                    ctx.drawImage(img, 0, 0, 256, 256);
                                    enhanceWaterZones(ctx);
                                };
                                canvas.style.filter = 'blur(2px)';
                                return canvas;
                            }

                            // Overzoom Logic: Client-side Mosaicking / Resampling
                            const scale = Math.pow(2, zoom - maxNativeZoom);
                            const pX = Math.floor(coord.x / scale);
                            const pY = Math.floor(coord.y / scale);

                            const img = new Image();
                            img.crossOrigin = "Anonymous";
                            img.src = `https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/${config.name}/default/${dateStr}/GoogleMapsCompatible_Level${config.zoom}/${maxNativeZoom}/${pY}/${pX}.${config.format}`;

                            img.onload = function () {
                                // Source Chunk Calculation
                                const pxPerTile = 256 / scale;
                                const localX = coord.x % scale;
                                const localY = coord.y % scale;

                                let sx = localX * pxPerTile;
                                let sy = localY * pxPerTile;

                                // Buffer Logic: Fix seams from parent boundaries
                                const buffer = 0.5;

                                let sx_adj = Math.max(0, sx - buffer);
                                let sy_adj = Math.max(0, sy - buffer);
                                let sw_adj = Math.min(256 - sx_adj, (sx + pxPerTile + buffer) - sx_adj);
                                let sh_adj = Math.min(256 - sy_adj, (sy + pxPerTile + buffer) - sy_adj);

                                let dx_adj = (sx_adj - sx) * scale;
                                let dy_adj = (sy_adj - sy) * scale;
                                let dw_adj = sw_adj * scale;
                                let dh_adj = sh_adj * scale;

                                ctx.drawImage(img, sx_adj, sy_adj, sw_adj, sh_adj, dx_adj, dy_adj, dw_adj, dh_adj);
                                enhanceWaterZones(ctx);
                            };

                            // Dynamic Blur: Increase smoothing as we zoom in closer to hide big pixels
                            // Scale 1 (Native) -> 2px
                            // Scale 8 (Zoom 9) -> ~7px
                            const blurVal = Math.max(2, scale * 0.8);
                            canvas.style.filter = `blur(${blurVal}px)`;
                            return canvas;
                        }
                    };

                } else if (layerId === 'FLOOD') {
                    // *** REAL FLOOD DATA WITH FILTERING ***
                    today.setDate(today.getDate() - 4);
                    dateStr = today.toISOString().split('T')[0];

                    config = {
                        name: 'MODIS_Combined_Flood_2-Day',
                        zoom: 9,
                        format: 'png',
                        opacity: 1.0, // Max opacity, we control alpha in canvas
                        isWaterLayer: true // Trigger Filter
                    };

                    // Use Canvas Filtered Layer
                    return new FilteredMapType(new google.maps.Size(256, 256), config, dateStr);
                }

                return null;
            };

            window.addEventListener('message', (event) => {
                const message = event.data;

                if (message.type === 'PAN_TO') {
                    geocoder.geocode({ 'address': message.region + ', Kenya' }, function (results, status) {
                        if (status === 'OK') {
                            map.setCenter(results[0].geometry.location);
                            map.setZoom(9);
                        } else {
                            console.error('Geocode failed: ' + status);
                        }
                    });
                }

                else if (message.type === 'SET_LAYER') {
                    console.log("Setting Layer:", message.layerId);

                    if (currentTileLayer) {
                        map.overlayMapTypes.removeAt(0);
                        currentTileLayer = null;
                    }

                    // Update Legend UI
                    updateLegend(message.layerId);

                    if (!message.layerId) return;

                    const layer = getGibsLayer(message.layerId);
                    if (layer) {
                        map.overlayMapTypes.push(layer);
                        currentTileLayer = layer;
                    }
                }
            });

            // Dynamic Legend Logic
            const updateLegend = (layerId) => {
                const container = document.getElementById('legendContainer');
                const title = container.querySelector('.legend-title');
                const source = container.querySelector('.legend-source');
                const gradient = container.querySelector('.legend-gradient');
                const labels = container.querySelector('.legend-labels');

                if (!layerId) {
                    container.style.display = 'none';
                    return;
                }
                container.style.display = 'block';

                // Helpers for Date
                const today = new Date();
                const formatDate = (d) => d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });

                if (layerId === 'VEGETATION') {
                    title.textContent = 'VEGETATION HEALTH';
                    source.textContent = `NASA MODIS • NDVI (8-Day)`;
                    gradient.style.background = 'linear-gradient(to right, #e5f5e0, #a1d99b, #31a354, #006d2c)';
                    labels.innerHTML = '<span>Stressed</span><span>Healthy</span>';

                } else if (layerId === 'FLOOD') {
                    title.textContent = 'FLOOD RISK & DETECTION';
                    today.setDate(today.getDate() - 2);
                    source.textContent = `NASA MODIS • ${formatDate(today)}`;

                    // Gradient: Blue (Normal) -> Yellow (Watch) -> Orange (Warning) -> Red (Danger)
                    gradient.style.background = 'linear-gradient(to right, #00BFFF 25%, #FFD700 50%, #FF4500 75%, #8B0000 100%)';

                    // Simple labels matching the gradient
                    labels.innerHTML = `
                        <div style="display:flex; justify-content:space-between; width:100%;">
                            <span>Normal</span>
                            <span>Watch</span>
                            <span>Danger</span>
                        </div>
                    `;

                } else if (layerId === 'HEAT') {
                    title.textContent = 'URBANIZATION';
                    source.textContent = 'NASA City Lights • Cloud Free';
                    // Night Lights: Black (Rural) -> Gold (Developed) -> White (Urban)
                    // Using RGBA to match the layer's 0.6 opacity, showing that "Black" is actually transparent
                    gradient.style.background = 'linear-gradient(to right, rgba(0,0,0,0.6), rgba(92,64,0,0.8), rgba(212,175,55,1), #ffffff)';
                    labels.innerHTML = '<span>Rural</span><span>Developed</span><span>Urban</span>';

                } else if (layerId === 'AIR') {
                    title.textContent = 'AIR QUALITY';
                    source.textContent = 'Google Air Quality API • Real-time';
                    // US AQI Standard Color Scale
                    gradient.style.background = 'linear-gradient(to right, #00E400, #FFFF00, #FF7E00, #FF0000, #8F3F97, #7E0023)';
                    labels.innerHTML = '<span>Good</span><span>Moderate</span><span>Unhealthy</span><span>Very Unhealthy</span><span>Hazardous</span>';

                } else if (layerId === 'WATER') {
                    // Calculate same dynamic date for label
                    const labelDate = new Date();
                    if (labelDate.getFullYear() > 2024) labelDate.setFullYear(2024);
                    labelDate.setDate(labelDate.getDate() - 7);

                    title.textContent = 'SOIL MOISTURE';
                    source.textContent = `NASA SMAP • Root Zone (${formatDate(labelDate)} ${labelDate.getFullYear()})`;
                    // Visual Palette: Faint Brown (Dry) -> Vibrant Blue (Wet) represents the filtered view
                    gradient.style.background = 'linear-gradient(to right, rgba(139,69,19,0.3), rgba(144,238,144,0.6), rgba(0,198,255,1), rgba(0,0,255,1))';
                    labels.innerHTML = '<span>Low Avail.</span><span>Moderate</span><span>High Avail.</span>';
                }
            };
        }
    </script>
    <script src="config.js"></script>
    <script>
        // Dynamically load Google Maps with key from config.js
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=${CONFIG.GOOGLE_MAPS_API_KEY}&libraries=places&loading=async&callback=initMap`;
        script.async = true;
        script.defer = true;
        document.head.appendChild(script);
    </script>
</body>

</html>