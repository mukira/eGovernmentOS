import { c as Be, r as a, v as et, j as p, f as me, l as Se, i as W, e as ct, h as H, k as P, a as fe, w as lo, b as uo, x as fo, y as Ge, d as We, t as ce, u as tt, m as po, n as mo, p as ho, o as go, F as wo, D as xo, z as vo, A as yo, M as Ft, E as bo } from "./product_logo-C96HwpIU.js"; (function () { try { var e = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {}; e.SENTRY_RELEASE = { id: "384410028dc6aac75eb61d6b08dc7127d516d4af" } } catch { } })(); try { (function () { var e = typeof window < "u" ? window : typeof global < "u" ? global : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {}, t = new e.Error().stack; t && (e._sentryDebugIds = e._sentryDebugIds || {}, e._sentryDebugIds[t] = "4b376f34-4d18-4470-b9e1-c7f97772466b", e._sentryDebugIdIdentifier = "sentry-dbid-4b376f34-4d18-4470-b9e1-c7f97772466b") })() } catch { } const ec = a.forwardRef((e, t) => {
    const n = tt(), o = `c1-${n}`, r = `c2-${n}`, s = `d1-${n}`, i = `d2-${n}`;
    return p.jsxs("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024",
        ...e,
        ref: t,
        children: [
            p.jsxs("g", {
                children: [
                    p.jsx("circle", { cx: "513.3", cy: "510.8", r: "454.9", fill: "none" }),
                    p.jsxs("g", {
                        children: [
                            p.jsx("defs", {
                                children: p.jsx("circle", { id: s, cx: "513.3", cy: "510.8", r: "454.9" })
                            }),
                            p.jsx("clipPath", {
                                id: o,
                                children: p.jsx("use", { href: `#${s}`, style: { overflow: "visible" } })
                            }),
                            p.jsx("circle", {
                                fill: "none",
                                stroke: "white",
                                strokeWidth: "209",
                                strokeMiterlimit: "10",
                                clipPath: `url(#${o})`,
                                cx: "758.2",
                                cy: "988.4",
                                r: "411.5"
                            })
                        ]
                    }),
                    p.jsxs("g", {
                        children: [
                            p.jsx("defs", {
                                children: p.jsx("circle", { id: i, cx: "513.3", cy: "510.8", r: "454.9" })
                            }),
                            p.jsx("clipPath", {
                                id: r,
                                children: p.jsx("use", { href: `#${i}`, style: { overflow: "visible" } })
                            }),
                            p.jsx("circle", {
                                fill: "none",
                                stroke: "white",
                                strokeWidth: "209",
                                strokeMiterlimit: "10",
                                clipPath: `url(#${r})`,
                                cx: "262",
                                cy: "81.4",
                                r: "411.5"
                            })
                        ]
                    })
                ]
            })
        ]
    })
});
ec.displayName = "BotIcon"; const Ro = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]], Mo = Be("circle", Ro); const So = [["path", { d: "M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401", key: "kfwtm" }]], Eo = Be("moon", So); const _o = [["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }], ["path", { d: "M12 2v2", key: "tus03m" }], ["path", { d: "M12 20v2", key: "1lh1kg" }], ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }], ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }], ["path", { d: "M2 12h2", key: "1t8f8n" }], ["path", { d: "M20 12h2", key: "1q8mjw" }], ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }], ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]], Ao = Be("sun", _o); function tc(e, t) { if (e == null) return {}; var n = {}; for (var o in e) if ({}.hasOwnProperty.call(e, o)) { if (t.indexOf(o) !== -1) continue; n[o] = e[o] } return n } function Po(e) { const t = a.useRef({ value: e, previous: e }); return a.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]) } function $t(e) { const [t, n] = a.useState(void 0); return et(() => { if (e) { n({ width: e.offsetWidth, height: e.offsetHeight }); const o = new ResizeObserver(r => { if (!Array.isArray(r) || !r.length) return; const s = r[0]; let i, c; if ("borderBoxSize" in s) { const u = s.borderBoxSize, f = Array.isArray(u) ? u[0] : u; i = f.inlineSize, c = f.blockSize } else i = e.offsetWidth, c = e.offsetHeight; n({ width: i, height: c }) }); return o.observe(e, { box: "border-box" }), () => o.unobserve(e) } else n(void 0) }, [e]), t } var Ve = "Checkbox", [Io] = me(Ve), [Do, at] = Io(Ve); function Oo(e) { const { __scopeCheckbox: t, checked: n, children: o, defaultChecked: r, disabled: s, form: i, name: c, onCheckedChange: u, required: f, value: d = "on", internal_do_not_use_render: l } = e, [m, h] = ct({ prop: n, defaultProp: r ?? !1, onChange: u, caller: Ve }), [g, v] = a.useState(null), [w, x] = a.useState(null), y = a.useRef(!1), b = g ? !!i || !!g.closest("form") : !0, C = { checked: m, disabled: s, setChecked: h, control: g, setControl: v, name: c, form: i, value: d, hasConsumerStoppedPropagationRef: y, required: f, defaultChecked: ne(r) ? !1 : r, isFormControl: b, bubbleInput: w, setBubbleInput: x }; return p.jsx(Do, { scope: t, ...C, children: To(l) ? l(C) : o }) } var Bt = "CheckboxTrigger", Gt = a.forwardRef(({ __scopeCheckbox: e, onKeyDown: t, onClick: n, ...o }, r) => { const { control: s, value: i, disabled: c, checked: u, required: f, setControl: d, setChecked: l, hasConsumerStoppedPropagationRef: m, isFormControl: h, bubbleInput: g } = at(Bt, e), v = H(r, d), w = a.useRef(u); return a.useEffect(() => { const x = s?.form; if (x) { const y = () => l(w.current); return x.addEventListener("reset", y), () => x.removeEventListener("reset", y) } }, [s, l]), p.jsx(W.button, { type: "button", role: "checkbox", "aria-checked": ne(u) ? "mixed" : u, "aria-required": f, "data-state": Ut(u), "data-disabled": c ? "" : void 0, disabled: c, value: i, ...o, ref: v, onKeyDown: P(t, x => { x.key === "Enter" && x.preventDefault() }), onClick: P(n, x => { l(y => ne(y) ? !0 : !y), g && h && (m.current = x.isPropagationStopped(), m.current || x.stopPropagation()) }) }) }); Gt.displayName = Bt; var Wt = a.forwardRef((e, t) => { const { __scopeCheckbox: n, name: o, checked: r, defaultChecked: s, required: i, disabled: c, value: u, onCheckedChange: f, form: d, ...l } = e; return p.jsx(Oo, { __scopeCheckbox: n, checked: r, defaultChecked: s, disabled: c, required: i, onCheckedChange: f, name: o, form: d, value: u, internal_do_not_use_render: ({ isFormControl: m }) => p.jsxs(p.Fragment, { children: [p.jsx(Gt, { ...l, ref: t, __scopeCheckbox: n }), m && p.jsx(Ht, { __scopeCheckbox: n })] }) }) }); Wt.displayName = Ve; var Vt = "CheckboxIndicator", Kt = a.forwardRef((e, t) => { const { __scopeCheckbox: n, forceMount: o, ...r } = e, s = at(Vt, n); return p.jsx(Se, { present: o || ne(s.checked) || s.checked === !0, children: p.jsx(W.span, { "data-state": Ut(s.checked), "data-disabled": s.disabled ? "" : void 0, ...r, ref: t, style: { pointerEvents: "none", ...e.style } }) }) }); Kt.displayName = Vt; var zt = "CheckboxBubbleInput", Ht = a.forwardRef(({ __scopeCheckbox: e, ...t }, n) => { const { control: o, hasConsumerStoppedPropagationRef: r, checked: s, defaultChecked: i, required: c, disabled: u, name: f, value: d, form: l, bubbleInput: m, setBubbleInput: h } = at(zt, e), g = H(n, h), v = Po(s), w = $t(o); a.useEffect(() => { const y = m; if (!y) return; const b = window.HTMLInputElement.prototype, M = Object.getOwnPropertyDescriptor(b, "checked").set, _ = !r.current; if (v !== s && M) { const E = new Event("click", { bubbles: _ }); y.indeterminate = ne(s), M.call(y, ne(s) ? !1 : s), y.dispatchEvent(E) } }, [m, v, s, r]); const x = a.useRef(ne(s) ? !1 : s); return p.jsx(W.input, { type: "checkbox", "aria-hidden": !0, defaultChecked: i ?? x.current, required: c, disabled: u, name: f, value: d, form: l, ...t, tabIndex: -1, ref: g, style: { ...t.style, ...w, position: "absolute", pointerEvents: "none", opacity: 0, margin: 0, transform: "translateX(-100%)" } }) }); Ht.displayName = zt; function To(e) { return typeof e == "function" } function ne(e) { return e === "indeterminate" } function Ut(e) { return ne(e) ? "indeterminate" : e ? "checked" : "unchecked" } function nc({ className: e, ...t }) { return p.jsx(Wt, { "data-slot": "checkbox", className: fe("peer size-4 shrink-0 rounded-[4px] border border-input shadow-xs outline-none transition-shadow focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50 disabled:cursor-not-allowed disabled:opacity-50 aria-invalid:border-destructive aria-invalid:ring-destructive/20 data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:bg-input/30 dark:data-[state=checked]:bg-primary dark:aria-invalid:ring-destructive/40", e), ...t, children: p.jsx(Kt, { "data-slot": "checkbox-indicator", className: "grid place-content-center text-current transition-none", children: p.jsx(lo, { className: "size-3.5" }) }) }) } var ko = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], No = ko.reduce((e, t) => { const n = uo(`Primitive.${t}`), o = a.forwardRef((r, s) => { const { asChild: i, ...c } = r, u = i ? n : t; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), p.jsx(u, { ...c, ref: s }) }); return o.displayName = `Primitive.${t}`, { ...e, [t]: o } }, {}), jo = "Label", Yt = a.forwardRef((e, t) => p.jsx(No.label, { ...e, ref: t, onMouseDown: n => { n.target.closest("button, input, select, textarea") || (e.onMouseDown?.(n), !n.defaultPrevented && n.detail > 1 && n.preventDefault()) } })); Yt.displayName = jo; var Lo = Yt; function oc({ className: e, ...t }) { return p.jsx(Lo, { "data-slot": "label", className: fe("flex select-none items-center gap-2 font-medium text-sm leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-50 group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50", e), ...t }) } const Fo = ["top", "right", "bottom", "left"], oe = Math.min, V = Math.max, ke = Math.round, Oe = Math.floor, Z = e => ({ x: e, y: e }), $o = { left: "right", right: "left", bottom: "top", top: "bottom" }, Bo = { start: "end", end: "start" }; function nt(e, t, n) { return V(e, oe(t, n)) } function ee(e, t) { return typeof e == "function" ? e(t) : e } function te(e) { return e.split("-")[0] } function he(e) { return e.split("-")[1] } function lt(e) { return e === "x" ? "y" : "x" } function ut(e) { return e === "y" ? "height" : "width" } const Go = new Set(["top", "bottom"]); function q(e) { return Go.has(te(e)) ? "y" : "x" } function dt(e) { return lt(q(e)) } function Wo(e, t, n) { n === void 0 && (n = !1); const o = he(e), r = dt(e), s = ut(r); let i = r === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top"; return t.reference[s] > t.floating[s] && (i = Ne(i)), [i, Ne(i)] } function Vo(e) { const t = Ne(e); return [ot(e), t, ot(t)] } function ot(e) { return e.replace(/start|end/g, t => Bo[t]) } const Mt = ["left", "right"], St = ["right", "left"], Ko = ["top", "bottom"], zo = ["bottom", "top"]; function Ho(e, t, n) { switch (e) { case "top": case "bottom": return n ? t ? St : Mt : t ? Mt : St; case "left": case "right": return t ? Ko : zo; default: return [] } } function Uo(e, t, n, o) { const r = he(e); let s = Ho(te(e), n === "start", o); return r && (s = s.map(i => i + "-" + r), t && (s = s.concat(s.map(ot)))), s } function Ne(e) { return e.replace(/left|right|bottom|top/g, t => $o[t]) } function Yo(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function Xt(e) { return typeof e != "number" ? Yo(e) : { top: e, right: e, bottom: e, left: e } } function je(e) { const { x: t, y: n, width: o, height: r } = e; return { width: o, height: r, top: n, left: t, right: t + o, bottom: n + r, x: t, y: n } } function Et(e, t, n) { let { reference: o, floating: r } = e; const s = q(t), i = dt(t), c = ut(i), u = te(t), f = s === "y", d = o.x + o.width / 2 - r.width / 2, l = o.y + o.height / 2 - r.height / 2, m = o[c] / 2 - r[c] / 2; let h; switch (u) { case "top": h = { x: d, y: o.y - r.height }; break; case "bottom": h = { x: d, y: o.y + o.height }; break; case "right": h = { x: o.x + o.width, y: l }; break; case "left": h = { x: o.x - r.width, y: l }; break; default: h = { x: o.x, y: o.y } }switch (he(t)) { case "start": h[i] -= m * (n && f ? -1 : 1); break; case "end": h[i] += m * (n && f ? -1 : 1); break }return h } const Xo = async (e, t, n) => { const { placement: o = "bottom", strategy: r = "absolute", middleware: s = [], platform: i } = n, c = s.filter(Boolean), u = await (i.isRTL == null ? void 0 : i.isRTL(t)); let f = await i.getElementRects({ reference: e, floating: t, strategy: r }), { x: d, y: l } = Et(f, o, u), m = o, h = {}, g = 0; for (let v = 0; v < c.length; v++) { const { name: w, fn: x } = c[v], { x: y, y: b, data: C, reset: M } = await x({ x: d, y: l, initialPlacement: o, placement: m, strategy: r, middlewareData: h, rects: f, platform: i, elements: { reference: e, floating: t } }); d = y ?? d, l = b ?? l, h = { ...h, [w]: { ...h[w], ...C } }, M && g <= 50 && (g++, typeof M == "object" && (M.placement && (m = M.placement), M.rects && (f = M.rects === !0 ? await i.getElementRects({ reference: e, floating: t, strategy: r }) : M.rects), { x: d, y: l } = Et(f, m, u)), v = -1) } return { x: d, y: l, placement: m, strategy: r, middlewareData: h } }; async function be(e, t) { var n; t === void 0 && (t = {}); const { x: o, y: r, platform: s, rects: i, elements: c, strategy: u } = e, { boundary: f = "clippingAncestors", rootBoundary: d = "viewport", elementContext: l = "floating", altBoundary: m = !1, padding: h = 0 } = ee(t, e), g = Xt(h), w = c[m ? l === "floating" ? "reference" : "floating" : l], x = je(await s.getClippingRect({ element: (n = await (s.isElement == null ? void 0 : s.isElement(w))) == null || n ? w : w.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)), boundary: f, rootBoundary: d, strategy: u })), y = l === "floating" ? { x: o, y: r, width: i.floating.width, height: i.floating.height } : i.reference, b = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), C = await (s.isElement == null ? void 0 : s.isElement(b)) ? await (s.getScale == null ? void 0 : s.getScale(b)) || { x: 1, y: 1 } : { x: 1, y: 1 }, M = je(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: c, rect: y, offsetParent: b, strategy: u }) : y); return { top: (x.top - M.top + g.top) / C.y, bottom: (M.bottom - x.bottom + g.bottom) / C.y, left: (x.left - M.left + g.left) / C.x, right: (M.right - x.right + g.right) / C.x } } const qo = e => ({ name: "arrow", options: e, async fn(t) { const { x: n, y: o, placement: r, rects: s, platform: i, elements: c, middlewareData: u } = t, { element: f, padding: d = 0 } = ee(e, t) || {}; if (f == null) return {}; const l = Xt(d), m = { x: n, y: o }, h = dt(r), g = ut(h), v = await i.getDimensions(f), w = h === "y", x = w ? "top" : "left", y = w ? "bottom" : "right", b = w ? "clientHeight" : "clientWidth", C = s.reference[g] + s.reference[h] - m[h] - s.floating[g], M = m[h] - s.reference[h], _ = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(f)); let E = _ ? _[b] : 0; (!E || !await (i.isElement == null ? void 0 : i.isElement(_))) && (E = c.floating[b] || s.floating[g]); const A = C / 2 - M / 2, k = E / 2 - v[g] / 2 - 1, D = oe(l[x], k), N = oe(l[y], k), j = D, T = E - v[g] - N, O = E / 2 - v[g] / 2 + A, $ = nt(j, O, T), I = !u.arrow && he(r) != null && O !== $ && s.reference[g] / 2 - (O < j ? D : N) - v[g] / 2 < 0, L = I ? O < j ? O - j : O - T : 0; return { [h]: m[h] + L, data: { [h]: $, centerOffset: O - $ - L, ...I && { alignmentOffset: L } }, reset: I } } }), Zo = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) { var n, o; const { placement: r, middlewareData: s, rects: i, initialPlacement: c, platform: u, elements: f } = t, { mainAxis: d = !0, crossAxis: l = !0, fallbackPlacements: m, fallbackStrategy: h = "bestFit", fallbackAxisSideDirection: g = "none", flipAlignment: v = !0, ...w } = ee(e, t); if ((n = s.arrow) != null && n.alignmentOffset) return {}; const x = te(r), y = q(c), b = te(c) === c, C = await (u.isRTL == null ? void 0 : u.isRTL(f.floating)), M = m || (b || !v ? [Ne(c)] : Vo(c)), _ = g !== "none"; !m && _ && M.push(...Uo(c, v, g, C)); const E = [c, ...M], A = await be(t, w), k = []; let D = ((o = s.flip) == null ? void 0 : o.overflows) || []; if (d && k.push(A[x]), l) { const O = Wo(r, i, C); k.push(A[O[0]], A[O[1]]) } if (D = [...D, { placement: r, overflows: k }], !k.every(O => O <= 0)) { var N, j; const O = (((N = s.flip) == null ? void 0 : N.index) || 0) + 1, $ = E[O]; if ($ && (!(l === "alignment" ? y !== q($) : !1) || D.every(S => q(S.placement) === y ? S.overflows[0] > 0 : !0))) return { data: { index: O, overflows: D }, reset: { placement: $ } }; let I = (j = D.filter(L => L.overflows[0] <= 0).sort((L, S) => L.overflows[1] - S.overflows[1])[0]) == null ? void 0 : j.placement; if (!I) switch (h) { case "bestFit": { var T; const L = (T = D.filter(S => { if (_) { const R = q(S.placement); return R === y || R === "y" } return !0 }).map(S => [S.placement, S.overflows.filter(R => R > 0).reduce((R, B) => R + B, 0)]).sort((S, R) => S[1] - R[1])[0]) == null ? void 0 : T[0]; L && (I = L); break } case "initialPlacement": I = c; break }if (r !== I) return { reset: { placement: I } } } return {} } } }; function _t(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function At(e) { return Fo.some(t => e[t] >= 0) } const Jo = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: n } = t, { strategy: o = "referenceHidden", ...r } = ee(e, t); switch (o) { case "referenceHidden": { const s = await be(t, { ...r, elementContext: "reference" }), i = _t(s, n.reference); return { data: { referenceHiddenOffsets: i, referenceHidden: At(i) } } } case "escaped": { const s = await be(t, { ...r, altBoundary: !0 }), i = _t(s, n.floating); return { data: { escapedOffsets: i, escaped: At(i) } } } default: return {} } } } }, qt = new Set(["left", "top"]); async function Qo(e, t) { const { placement: n, platform: o, elements: r } = e, s = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), i = te(n), c = he(n), u = q(n) === "y", f = qt.has(i) ? -1 : 1, d = s && u ? -1 : 1, l = ee(t, e); let { mainAxis: m, crossAxis: h, alignmentAxis: g } = typeof l == "number" ? { mainAxis: l, crossAxis: 0, alignmentAxis: null } : { mainAxis: l.mainAxis || 0, crossAxis: l.crossAxis || 0, alignmentAxis: l.alignmentAxis }; return c && typeof g == "number" && (h = c === "end" ? g * -1 : g), u ? { x: h * d, y: m * f } : { x: m * f, y: h * d } } const er = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) { var n, o; const { x: r, y: s, placement: i, middlewareData: c } = t, u = await Qo(t, e); return i === ((n = c.offset) == null ? void 0 : n.placement) && (o = c.arrow) != null && o.alignmentOffset ? {} : { x: r + u.x, y: s + u.y, data: { ...u, placement: i } } } } }, tr = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) { const { x: n, y: o, placement: r } = t, { mainAxis: s = !0, crossAxis: i = !1, limiter: c = { fn: w => { let { x, y } = w; return { x, y } } }, ...u } = ee(e, t), f = { x: n, y: o }, d = await be(t, u), l = q(te(r)), m = lt(l); let h = f[m], g = f[l]; if (s) { const w = m === "y" ? "top" : "left", x = m === "y" ? "bottom" : "right", y = h + d[w], b = h - d[x]; h = nt(y, h, b) } if (i) { const w = l === "y" ? "top" : "left", x = l === "y" ? "bottom" : "right", y = g + d[w], b = g - d[x]; g = nt(y, g, b) } const v = c.fn({ ...t, [m]: h, [l]: g }); return { ...v, data: { x: v.x - n, y: v.y - o, enabled: { [m]: s, [l]: i } } } } } }, nr = function (e) { return e === void 0 && (e = {}), { options: e, fn(t) { const { x: n, y: o, placement: r, rects: s, middlewareData: i } = t, { offset: c = 0, mainAxis: u = !0, crossAxis: f = !0 } = ee(e, t), d = { x: n, y: o }, l = q(r), m = lt(l); let h = d[m], g = d[l]; const v = ee(c, t), w = typeof v == "number" ? { mainAxis: v, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...v }; if (u) { const b = m === "y" ? "height" : "width", C = s.reference[m] - s.floating[b] + w.mainAxis, M = s.reference[m] + s.reference[b] - w.mainAxis; h < C ? h = C : h > M && (h = M) } if (f) { var x, y; const b = m === "y" ? "width" : "height", C = qt.has(te(r)), M = s.reference[l] - s.floating[b] + (C && ((x = i.offset) == null ? void 0 : x[l]) || 0) + (C ? 0 : w.crossAxis), _ = s.reference[l] + s.reference[b] + (C ? 0 : ((y = i.offset) == null ? void 0 : y[l]) || 0) - (C ? w.crossAxis : 0); g < M ? g = M : g > _ && (g = _) } return { [m]: h, [l]: g } } } }, or = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) { var n, o; const { placement: r, rects: s, platform: i, elements: c } = t, { apply: u = () => { }, ...f } = ee(e, t), d = await be(t, f), l = te(r), m = he(r), h = q(r) === "y", { width: g, height: v } = s.floating; let w, x; l === "top" || l === "bottom" ? (w = l, x = m === (await (i.isRTL == null ? void 0 : i.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (x = l, w = m === "end" ? "top" : "bottom"); const y = v - d.top - d.bottom, b = g - d.left - d.right, C = oe(v - d[w], y), M = oe(g - d[x], b), _ = !t.middlewareData.shift; let E = C, A = M; if ((n = t.middlewareData.shift) != null && n.enabled.x && (A = b), (o = t.middlewareData.shift) != null && o.enabled.y && (E = y), _ && !m) { const D = V(d.left, 0), N = V(d.right, 0), j = V(d.top, 0), T = V(d.bottom, 0); h ? A = g - 2 * (D !== 0 || N !== 0 ? D + N : V(d.left, d.right)) : E = v - 2 * (j !== 0 || T !== 0 ? j + T : V(d.top, d.bottom)) } await u({ ...t, availableWidth: A, availableHeight: E }); const k = await i.getDimensions(c.floating); return g !== k.width || v !== k.height ? { reset: { rects: !0 } } : {} } } }; function Ke() { return typeof window < "u" } function ge(e) { return Zt(e) ? (e.nodeName || "").toLowerCase() : "#document" } function K(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function Q(e) { var t; return (t = (Zt(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement } function Zt(e) { return Ke() ? e instanceof Node || e instanceof K(e).Node : !1 } function U(e) { return Ke() ? e instanceof Element || e instanceof K(e).Element : !1 } function J(e) { return Ke() ? e instanceof HTMLElement || e instanceof K(e).HTMLElement : !1 } function Pt(e) { return !Ke() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof K(e).ShadowRoot } const rr = new Set(["inline", "contents"]); function Ee(e) { const { overflow: t, overflowX: n, overflowY: o, display: r } = Y(e); return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !rr.has(r) } const sr = new Set(["table", "td", "th"]); function ir(e) { return sr.has(ge(e)) } const cr = [":popover-open", ":modal"]; function ze(e) { return cr.some(t => { try { return e.matches(t) } catch { return !1 } }) } const ar = ["transform", "translate", "scale", "rotate", "perspective"], lr = ["transform", "translate", "scale", "rotate", "perspective", "filter"], ur = ["paint", "layout", "strict", "content"]; function ft(e) { const t = pt(), n = U(e) ? Y(e) : e; return ar.some(o => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || lr.some(o => (n.willChange || "").includes(o)) || ur.some(o => (n.contain || "").includes(o)) } function dr(e) { let t = re(e); for (; J(t) && !pe(t);) { if (ft(t)) return t; if (ze(t)) return null; t = re(t) } return null } function pt() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } const fr = new Set(["html", "body", "#document"]); function pe(e) { return fr.has(ge(e)) } function Y(e) { return K(e).getComputedStyle(e) } function He(e) { return U(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function re(e) { if (ge(e) === "html") return e; const t = e.assignedSlot || e.parentNode || Pt(e) && e.host || Q(e); return Pt(t) ? t.host : t } function Jt(e) { const t = re(e); return pe(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : J(t) && Ee(t) ? t : Jt(t) } function Ce(e, t, n) { var o; t === void 0 && (t = []), n === void 0 && (n = !0); const r = Jt(e), s = r === ((o = e.ownerDocument) == null ? void 0 : o.body), i = K(r); if (s) { const c = rt(i); return t.concat(i, i.visualViewport || [], Ee(r) ? r : [], c && n ? Ce(c) : []) } return t.concat(r, Ce(r, [], n)) } function rt(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function Qt(e) { const t = Y(e); let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0; const r = J(e), s = r ? e.offsetWidth : n, i = r ? e.offsetHeight : o, c = ke(n) !== s || ke(o) !== i; return c && (n = s, o = i), { width: n, height: o, $: c } } function mt(e) { return U(e) ? e : e.contextElement } function de(e) { const t = mt(e); if (!J(t)) return Z(1); const n = t.getBoundingClientRect(), { width: o, height: r, $: s } = Qt(t); let i = (s ? ke(n.width) : n.width) / o, c = (s ? ke(n.height) : n.height) / r; return (!i || !Number.isFinite(i)) && (i = 1), (!c || !Number.isFinite(c)) && (c = 1), { x: i, y: c } } const pr = Z(0); function en(e) { const t = K(e); return !pt() || !t.visualViewport ? pr : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function mr(e, t, n) { return t === void 0 && (t = !1), !n || t && n !== K(e) ? !1 : t } function ae(e, t, n, o) { t === void 0 && (t = !1), n === void 0 && (n = !1); const r = e.getBoundingClientRect(), s = mt(e); let i = Z(1); t && (o ? U(o) && (i = de(o)) : i = de(e)); const c = mr(s, n, o) ? en(s) : Z(0); let u = (r.left + c.x) / i.x, f = (r.top + c.y) / i.y, d = r.width / i.x, l = r.height / i.y; if (s) { const m = K(s), h = o && U(o) ? K(o) : o; let g = m, v = rt(g); for (; v && o && h !== g;) { const w = de(v), x = v.getBoundingClientRect(), y = Y(v), b = x.left + (v.clientLeft + parseFloat(y.paddingLeft)) * w.x, C = x.top + (v.clientTop + parseFloat(y.paddingTop)) * w.y; u *= w.x, f *= w.y, d *= w.x, l *= w.y, u += b, f += C, g = K(v), v = rt(g) } } return je({ width: d, height: l, x: u, y: f }) } function Ue(e, t) { const n = He(e).scrollLeft; return t ? t.left + n : ae(Q(e)).left + n } function tn(e, t) { const n = e.getBoundingClientRect(), o = n.left + t.scrollLeft - Ue(e, n), r = n.top + t.scrollTop; return { x: o, y: r } } function hr(e) { let { elements: t, rect: n, offsetParent: o, strategy: r } = e; const s = r === "fixed", i = Q(o), c = t ? ze(t.floating) : !1; if (o === i || c && s) return n; let u = { scrollLeft: 0, scrollTop: 0 }, f = Z(1); const d = Z(0), l = J(o); if ((l || !l && !s) && ((ge(o) !== "body" || Ee(i)) && (u = He(o)), J(o))) { const h = ae(o); f = de(o), d.x = h.x + o.clientLeft, d.y = h.y + o.clientTop } const m = i && !l && !s ? tn(i, u) : Z(0); return { width: n.width * f.x, height: n.height * f.y, x: n.x * f.x - u.scrollLeft * f.x + d.x + m.x, y: n.y * f.y - u.scrollTop * f.y + d.y + m.y } } function gr(e) { return Array.from(e.getClientRects()) } function wr(e) { const t = Q(e), n = He(e), o = e.ownerDocument.body, r = V(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), s = V(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight); let i = -n.scrollLeft + Ue(e); const c = -n.scrollTop; return Y(o).direction === "rtl" && (i += V(t.clientWidth, o.clientWidth) - r), { width: r, height: s, x: i, y: c } } const It = 25; function xr(e, t) { const n = K(e), o = Q(e), r = n.visualViewport; let s = o.clientWidth, i = o.clientHeight, c = 0, u = 0; if (r) { s = r.width, i = r.height; const d = pt(); (!d || d && t === "fixed") && (c = r.offsetLeft, u = r.offsetTop) } const f = Ue(o); if (f <= 0) { const d = o.ownerDocument, l = d.body, m = getComputedStyle(l), h = d.compatMode === "CSS1Compat" && parseFloat(m.marginLeft) + parseFloat(m.marginRight) || 0, g = Math.abs(o.clientWidth - l.clientWidth - h); g <= It && (s -= g) } else f <= It && (s += f); return { width: s, height: i, x: c, y: u } } const vr = new Set(["absolute", "fixed"]); function yr(e, t) { const n = ae(e, !0, t === "fixed"), o = n.top + e.clientTop, r = n.left + e.clientLeft, s = J(e) ? de(e) : Z(1), i = e.clientWidth * s.x, c = e.clientHeight * s.y, u = r * s.x, f = o * s.y; return { width: i, height: c, x: u, y: f } } function Dt(e, t, n) { let o; if (t === "viewport") o = xr(e, n); else if (t === "document") o = wr(Q(e)); else if (U(t)) o = yr(t, n); else { const r = en(e); o = { x: t.x - r.x, y: t.y - r.y, width: t.width, height: t.height } } return je(o) } function nn(e, t) { const n = re(e); return n === t || !U(n) || pe(n) ? !1 : Y(n).position === "fixed" || nn(n, t) } function br(e, t) { const n = t.get(e); if (n) return n; let o = Ce(e, [], !1).filter(c => U(c) && ge(c) !== "body"), r = null; const s = Y(e).position === "fixed"; let i = s ? re(e) : e; for (; U(i) && !pe(i);) { const c = Y(i), u = ft(i); !u && c.position === "fixed" && (r = null), (s ? !u && !r : !u && c.position === "static" && !!r && vr.has(r.position) || Ee(i) && !u && nn(e, i)) ? o = o.filter(d => d !== i) : r = c, i = re(i) } return t.set(e, o), o } function Cr(e) { let { element: t, boundary: n, rootBoundary: o, strategy: r } = e; const i = [...n === "clippingAncestors" ? ze(t) ? [] : br(t, this._c) : [].concat(n), o], c = i[0], u = i.reduce((f, d) => { const l = Dt(t, d, r); return f.top = V(l.top, f.top), f.right = oe(l.right, f.right), f.bottom = oe(l.bottom, f.bottom), f.left = V(l.left, f.left), f }, Dt(t, c, r)); return { width: u.right - u.left, height: u.bottom - u.top, x: u.left, y: u.top } } function Rr(e) { const { width: t, height: n } = Qt(e); return { width: t, height: n } } function Mr(e, t, n) { const o = J(t), r = Q(t), s = n === "fixed", i = ae(e, !0, s, t); let c = { scrollLeft: 0, scrollTop: 0 }; const u = Z(0); function f() { u.x = Ue(r) } if (o || !o && !s) if ((ge(t) !== "body" || Ee(r)) && (c = He(t)), o) { const h = ae(t, !0, s, t); u.x = h.x + t.clientLeft, u.y = h.y + t.clientTop } else r && f(); s && !o && r && f(); const d = r && !o && !s ? tn(r, c) : Z(0), l = i.left + c.scrollLeft - u.x - d.x, m = i.top + c.scrollTop - u.y - d.y; return { x: l, y: m, width: i.width, height: i.height } } function Ze(e) { return Y(e).position === "static" } function Ot(e, t) { if (!J(e) || Y(e).position === "fixed") return null; if (t) return t(e); let n = e.offsetParent; return Q(e) === n && (n = n.ownerDocument.body), n } function on(e, t) { const n = K(e); if (ze(e)) return n; if (!J(e)) { let r = re(e); for (; r && !pe(r);) { if (U(r) && !Ze(r)) return r; r = re(r) } return n } let o = Ot(e, t); for (; o && ir(o) && Ze(o);)o = Ot(o, t); return o && pe(o) && Ze(o) && !ft(o) ? n : o || dr(e) || n } const Sr = async function (e) { const t = this.getOffsetParent || on, n = this.getDimensions, o = await n(e.floating); return { reference: Mr(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: o.width, height: o.height } } }; function Er(e) { return Y(e).direction === "rtl" } const _r = { convertOffsetParentRelativeRectToViewportRelativeRect: hr, getDocumentElement: Q, getClippingRect: Cr, getOffsetParent: on, getElementRects: Sr, getClientRects: gr, getDimensions: Rr, getScale: de, isElement: U, isRTL: Er }; function rn(e, t) { return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height } function Ar(e, t) { let n = null, o; const r = Q(e); function s() { var c; clearTimeout(o), (c = n) == null || c.disconnect(), n = null } function i(c, u) { c === void 0 && (c = !1), u === void 0 && (u = 1), s(); const f = e.getBoundingClientRect(), { left: d, top: l, width: m, height: h } = f; if (c || t(), !m || !h) return; const g = Oe(l), v = Oe(r.clientWidth - (d + m)), w = Oe(r.clientHeight - (l + h)), x = Oe(d), b = { rootMargin: -g + "px " + -v + "px " + -w + "px " + -x + "px", threshold: V(0, oe(1, u)) || 1 }; let C = !0; function M(_) { const E = _[0].intersectionRatio; if (E !== u) { if (!C) return i(); E ? i(!1, E) : o = setTimeout(() => { i(!1, 1e-7) }, 1e3) } E === 1 && !rn(f, e.getBoundingClientRect()) && i(), C = !1 } try { n = new IntersectionObserver(M, { ...b, root: r.ownerDocument }) } catch { n = new IntersectionObserver(M, b) } n.observe(e) } return i(!0), s } function Pr(e, t, n, o) { o === void 0 && (o = {}); const { ancestorScroll: r = !0, ancestorResize: s = !0, elementResize: i = typeof ResizeObserver == "function", layoutShift: c = typeof IntersectionObserver == "function", animationFrame: u = !1 } = o, f = mt(e), d = r || s ? [...f ? Ce(f) : [], ...Ce(t)] : []; d.forEach(x => { r && x.addEventListener("scroll", n, { passive: !0 }), s && x.addEventListener("resize", n) }); const l = f && c ? Ar(f, n) : null; let m = -1, h = null; i && (h = new ResizeObserver(x => { let [y] = x; y && y.target === f && h && (h.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => { var b; (b = h) == null || b.observe(t) })), n() }), f && !u && h.observe(f), h.observe(t)); let g, v = u ? ae(e) : null; u && w(); function w() { const x = ae(e); v && !rn(v, x) && n(), v = x, g = requestAnimationFrame(w) } return n(), () => { var x; d.forEach(y => { r && y.removeEventListener("scroll", n), s && y.removeEventListener("resize", n) }), l?.(), (x = h) == null || x.disconnect(), h = null, u && cancelAnimationFrame(g) } } const Ir = er, Dr = tr, Or = Zo, Tr = or, kr = Jo, Tt = qo, Nr = nr, jr = (e, t, n) => { const o = new Map, r = { platform: _r, ...n }, s = { ...r.platform, _c: o }; return Xo(e, t, { ...r, platform: s }) }; var Lr = typeof document < "u", Fr = function () { }, Te = Lr ? a.useLayoutEffect : Fr; function Le(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if (typeof e == "function" && e.toString() === t.toString()) return !0; let n, o, r; if (e && t && typeof e == "object") { if (Array.isArray(e)) { if (n = e.length, n !== t.length) return !1; for (o = n; o-- !== 0;)if (!Le(e[o], t[o])) return !1; return !0 } if (r = Object.keys(e), n = r.length, n !== Object.keys(t).length) return !1; for (o = n; o-- !== 0;)if (!{}.hasOwnProperty.call(t, r[o])) return !1; for (o = n; o-- !== 0;) { const s = r[o]; if (!(s === "_owner" && e.$$typeof) && !Le(e[s], t[s])) return !1 } return !0 } return e !== e && t !== t } function sn(e) { return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function kt(e, t) { const n = sn(e); return Math.round(t * n) / n } function Je(e) { const t = a.useRef(e); return Te(() => { t.current = e }), t } function $r(e) { e === void 0 && (e = {}); const { placement: t = "bottom", strategy: n = "absolute", middleware: o = [], platform: r, elements: { reference: s, floating: i } = {}, transform: c = !0, whileElementsMounted: u, open: f } = e, [d, l] = a.useState({ x: 0, y: 0, strategy: n, placement: t, middlewareData: {}, isPositioned: !1 }), [m, h] = a.useState(o); Le(m, o) || h(o); const [g, v] = a.useState(null), [w, x] = a.useState(null), y = a.useCallback(S => { S !== _.current && (_.current = S, v(S)) }, []), b = a.useCallback(S => { S !== E.current && (E.current = S, x(S)) }, []), C = s || g, M = i || w, _ = a.useRef(null), E = a.useRef(null), A = a.useRef(d), k = u != null, D = Je(u), N = Je(r), j = Je(f), T = a.useCallback(() => { if (!_.current || !E.current) return; const S = { placement: t, strategy: n, middleware: m }; N.current && (S.platform = N.current), jr(_.current, E.current, S).then(R => { const B = { ...R, isPositioned: j.current !== !1 }; O.current && !Le(A.current, B) && (A.current = B, fo.flushSync(() => { l(B) })) }) }, [m, t, n, N, j]); Te(() => { f === !1 && A.current.isPositioned && (A.current.isPositioned = !1, l(S => ({ ...S, isPositioned: !1 }))) }, [f]); const O = a.useRef(!1); Te(() => (O.current = !0, () => { O.current = !1 }), []), Te(() => { if (C && (_.current = C), M && (E.current = M), C && M) { if (D.current) return D.current(C, M, T); T() } }, [C, M, T, D, k]); const $ = a.useMemo(() => ({ reference: _, floating: E, setReference: y, setFloating: b }), [y, b]), I = a.useMemo(() => ({ reference: C, floating: M }), [C, M]), L = a.useMemo(() => { const S = { position: n, left: 0, top: 0 }; if (!I.floating) return S; const R = kt(I.floating, d.x), B = kt(I.floating, d.y); return c ? { ...S, transform: "translate(" + R + "px, " + B + "px)", ...sn(I.floating) >= 1.5 && { willChange: "transform" } } : { position: n, left: R, top: B } }, [n, c, I.floating, d.x, d.y]); return a.useMemo(() => ({ ...d, update: T, refs: $, elements: I, floatingStyles: L }), [d, T, $, I, L]) } const Br = e => { function t(n) { return {}.hasOwnProperty.call(n, "current") } return { name: "arrow", options: e, fn(n) { const { element: o, padding: r } = typeof e == "function" ? e(n) : e; return o && t(o) ? o.current != null ? Tt({ element: o.current, padding: r }).fn(n) : {} : o ? Tt({ element: o, padding: r }).fn(n) : {} } } }, Gr = (e, t) => ({ ...Ir(e), options: [e, t] }), Wr = (e, t) => ({ ...Dr(e), options: [e, t] }), Vr = (e, t) => ({ ...Nr(e), options: [e, t] }), Kr = (e, t) => ({ ...Or(e), options: [e, t] }), zr = (e, t) => ({ ...Tr(e), options: [e, t] }), Hr = (e, t) => ({ ...kr(e), options: [e, t] }), Ur = (e, t) => ({ ...Br(e), options: [e, t] }); var Yr = "Arrow", cn = a.forwardRef((e, t) => { const { children: n, width: o = 10, height: r = 5, ...s } = e; return p.jsx(W.svg, { ...s, ref: t, width: o, height: r, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: e.asChild ? n : p.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); cn.displayName = Yr; var Xr = cn, ht = "Popper", [an, ln] = me(ht), [qr, un] = an(ht), dn = e => { const { __scopePopper: t, children: n } = e, [o, r] = a.useState(null); return p.jsx(qr, { scope: t, anchor: o, onAnchorChange: r, children: n }) }; dn.displayName = ht; var fn = "PopperAnchor", pn = a.forwardRef((e, t) => { const { __scopePopper: n, virtualRef: o, ...r } = e, s = un(fn, n), i = a.useRef(null), c = H(t, i), u = a.useRef(null); return a.useEffect(() => { const f = u.current; u.current = o?.current || i.current, f !== u.current && s.onAnchorChange(u.current) }), o ? null : p.jsx(W.div, { ...r, ref: c }) }); pn.displayName = fn; var gt = "PopperContent", [Zr, Jr] = an(gt), mn = a.forwardRef((e, t) => { const { __scopePopper: n, side: o = "bottom", sideOffset: r = 0, align: s = "center", alignOffset: i = 0, arrowPadding: c = 0, avoidCollisions: u = !0, collisionBoundary: f = [], collisionPadding: d = 0, sticky: l = "partial", hideWhenDetached: m = !1, updatePositionStrategy: h = "optimized", onPlaced: g, ...v } = e, w = un(gt, n), [x, y] = a.useState(null), b = H(t, F => y(F)), [C, M] = a.useState(null), _ = $t(C), E = _?.width ?? 0, A = _?.height ?? 0, k = o + (s !== "center" ? "-" + s : ""), D = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, N = Array.isArray(f) ? f : [f], j = N.length > 0, T = { padding: D, boundary: N.filter(es), altBoundary: j }, { refs: O, floatingStyles: $, placement: I, isPositioned: L, middlewareData: S } = $r({ strategy: "fixed", placement: k, whileElementsMounted: (...F) => Pr(...F, { animationFrame: h === "always" }), elements: { reference: w.anchor }, middleware: [Gr({ mainAxis: r + A, alignmentAxis: i }), u && Wr({ mainAxis: !0, crossAxis: !1, limiter: l === "partial" ? Vr() : void 0, ...T }), u && Kr({ ...T }), zr({ ...T, apply: ({ elements: F, rects: ve, availableWidth: so, availableHeight: io }) => { const { width: co, height: ao } = ve.reference, De = F.floating.style; De.setProperty("--radix-popper-available-width", `${so}px`), De.setProperty("--radix-popper-available-height", `${io}px`), De.setProperty("--radix-popper-anchor-width", `${co}px`), De.setProperty("--radix-popper-anchor-height", `${ao}px`) } }), C && Ur({ element: C, padding: c }), ts({ arrowWidth: E, arrowHeight: A }), m && Hr({ strategy: "referenceHidden", ...T })] }), [R, B] = wn(I), X = Ge(g); et(() => { L && X?.() }, [L, X]); const se = S.arrow?.x, we = S.arrow?.y, xe = S.arrow?.centerOffset !== 0, [Ie, ie] = a.useState(); return et(() => { x && ie(window.getComputedStyle(x).zIndex) }, [x]), p.jsx("div", { ref: O.setFloating, "data-radix-popper-content-wrapper": "", style: { ...$, transform: L ? $.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: Ie, "--radix-popper-transform-origin": [S.transformOrigin?.x, S.transformOrigin?.y].join(" "), ...S.hide?.referenceHidden && { visibility: "hidden", pointerEvents: "none" } }, dir: e.dir, children: p.jsx(Zr, { scope: n, placedSide: R, onArrowChange: M, arrowX: se, arrowY: we, shouldHideArrow: xe, children: p.jsx(W.div, { "data-side": R, "data-align": B, ...v, ref: b, style: { ...v.style, animation: L ? void 0 : "none" } }) }) }) }); mn.displayName = gt; var hn = "PopperArrow", Qr = { top: "bottom", right: "left", bottom: "top", left: "right" }, gn = a.forwardRef(function (t, n) { const { __scopePopper: o, ...r } = t, s = Jr(hn, o), i = Qr[s.placedSide]; return p.jsx("span", { ref: s.onArrowChange, style: { position: "absolute", left: s.arrowX, top: s.arrowY, [i]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[s.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[s.placedSide], visibility: s.shouldHideArrow ? "hidden" : void 0 }, children: p.jsx(Xr, { ...r, ref: n, style: { ...r.style, display: "block" } }) }) }); gn.displayName = hn; function es(e) { return e !== null } var ts = e => ({ name: "transformOrigin", options: e, fn(t) { const { placement: n, rects: o, middlewareData: r } = t, i = r.arrow?.centerOffset !== 0, c = i ? 0 : e.arrowWidth, u = i ? 0 : e.arrowHeight, [f, d] = wn(n), l = { start: "0%", center: "50%", end: "100%" }[d], m = (r.arrow?.x ?? 0) + c / 2, h = (r.arrow?.y ?? 0) + u / 2; let g = "", v = ""; return f === "bottom" ? (g = i ? l : `${m}px`, v = `${-u}px`) : f === "top" ? (g = i ? l : `${m}px`, v = `${o.floating.height + u}px`) : f === "right" ? (g = `${-u}px`, v = i ? l : `${h}px`) : f === "left" && (g = `${o.floating.width + u}px`, v = i ? l : `${h}px`), { data: { x: g, y: v } } } }); function wn(e) { const [t, n = "center"] = e.split("-"); return [t, n] } var ns = dn, os = pn, rs = mn, ss = gn; function Nt(e) { const t = is(e), n = a.forwardRef((o, r) => { const { children: s, ...i } = o, c = a.Children.toArray(s), u = c.find(as); if (u) { const f = u.props.children, d = c.map(l => l === u ? a.Children.count(f) > 1 ? a.Children.only(null) : a.isValidElement(f) ? f.props.children : null : l); return p.jsx(t, { ...i, ref: r, children: a.isValidElement(f) ? a.cloneElement(f, void 0, d) : null }) } return p.jsx(t, { ...i, ref: r, children: s }) }); return n.displayName = `${e}.Slot`, n } function is(e) { const t = a.forwardRef((n, o) => { const { children: r, ...s } = n; if (a.isValidElement(r)) { const i = us(r), c = ls(s, r.props); return r.type !== a.Fragment && (c.ref = o ? We(o, i) : i), a.cloneElement(r, c) } return a.Children.count(r) > 1 ? a.Children.only(null) : null }); return t.displayName = `${e}.SlotClone`, t } var cs = Symbol("radix.slottable"); function as(e) { return a.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === cs } function ls(e, t) { const n = { ...t }; for (const o in t) { const r = e[o], s = t[o]; /^on[A-Z]/.test(o) ? r && s ? n[o] = (...c) => { const u = s(...c); return r(...c), u } : r && (n[o] = r) : o === "style" ? n[o] = { ...r, ...s } : o === "className" && (n[o] = [r, s].filter(Boolean).join(" ")) } return { ...e, ...n } } function us(e) { let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } function xn(e) { const t = e + "CollectionProvider", [n, o] = me(t), [r, s] = n(t, { collectionRef: { current: null }, itemMap: new Map }), i = v => { const { scope: w, children: x } = v, y = ce.useRef(null), b = ce.useRef(new Map).current; return p.jsx(r, { scope: w, itemMap: b, collectionRef: y, children: x }) }; i.displayName = t; const c = e + "CollectionSlot", u = Nt(c), f = ce.forwardRef((v, w) => { const { scope: x, children: y } = v, b = s(c, x), C = H(w, b.collectionRef); return p.jsx(u, { ref: C, children: y }) }); f.displayName = c; const d = e + "CollectionItemSlot", l = "data-radix-collection-item", m = Nt(d), h = ce.forwardRef((v, w) => { const { scope: x, children: y, ...b } = v, C = ce.useRef(null), M = H(w, C), _ = s(d, x); return ce.useEffect(() => (_.itemMap.set(C, { ref: C, ...b }), () => void _.itemMap.delete(C))), p.jsx(m, { [l]: "", ref: M, children: y }) }); h.displayName = d; function g(v) { const w = s(e + "CollectionConsumer", v); return ce.useCallback(() => { const y = w.collectionRef.current; if (!y) return []; const b = Array.from(y.querySelectorAll(`[${l}]`)); return Array.from(w.itemMap.values()).sort((_, E) => b.indexOf(_.ref.current) - b.indexOf(E.ref.current)) }, [w.collectionRef, w.itemMap]) } return [{ Provider: i, Slot: f, ItemSlot: h }, g, o] } var ds = a.createContext(void 0); function vn(e) { const t = a.useContext(ds); return e || t || "ltr" } var Qe = "rovingFocusGroup.onEntryFocus", fs = { bubbles: !1, cancelable: !0 }, _e = "RovingFocusGroup", [st, yn, ps] = xn(_e), [ms, bn] = me(_e, [ps]), [hs, gs] = ms(_e), Cn = a.forwardRef((e, t) => p.jsx(st.Provider, { scope: e.__scopeRovingFocusGroup, children: p.jsx(st.Slot, { scope: e.__scopeRovingFocusGroup, children: p.jsx(ws, { ...e, ref: t }) }) })); Cn.displayName = _e; var ws = a.forwardRef((e, t) => { const { __scopeRovingFocusGroup: n, orientation: o, loop: r = !1, dir: s, currentTabStopId: i, defaultCurrentTabStopId: c, onCurrentTabStopIdChange: u, onEntryFocus: f, preventScrollOnEntryFocus: d = !1, ...l } = e, m = a.useRef(null), h = H(t, m), g = vn(s), [v, w] = ct({ prop: i, defaultProp: c ?? null, onChange: u, caller: _e }), [x, y] = a.useState(!1), b = Ge(f), C = yn(n), M = a.useRef(!1), [_, E] = a.useState(0); return a.useEffect(() => { const A = m.current; if (A) return A.addEventListener(Qe, b), () => A.removeEventListener(Qe, b) }, [b]), p.jsx(hs, { scope: n, orientation: o, dir: g, loop: r, currentTabStopId: v, onItemFocus: a.useCallback(A => w(A), [w]), onItemShiftTab: a.useCallback(() => y(!0), []), onFocusableItemAdd: a.useCallback(() => E(A => A + 1), []), onFocusableItemRemove: a.useCallback(() => E(A => A - 1), []), children: p.jsx(W.div, { tabIndex: x || _ === 0 ? -1 : 0, "data-orientation": o, ...l, ref: h, style: { outline: "none", ...e.style }, onMouseDown: P(e.onMouseDown, () => { M.current = !0 }), onFocus: P(e.onFocus, A => { const k = !M.current; if (A.target === A.currentTarget && k && !x) { const D = new CustomEvent(Qe, fs); if (A.currentTarget.dispatchEvent(D), !D.defaultPrevented) { const N = C().filter(I => I.focusable), j = N.find(I => I.active), T = N.find(I => I.id === v), $ = [j, T, ...N].filter(Boolean).map(I => I.ref.current); Sn($, d) } } M.current = !1 }), onBlur: P(e.onBlur, () => y(!1)) }) }) }), Rn = "RovingFocusGroupItem", Mn = a.forwardRef((e, t) => { const { __scopeRovingFocusGroup: n, focusable: o = !0, active: r = !1, tabStopId: s, children: i, ...c } = e, u = tt(), f = s || u, d = gs(Rn, n), l = d.currentTabStopId === f, m = yn(n), { onFocusableItemAdd: h, onFocusableItemRemove: g, currentTabStopId: v } = d; return a.useEffect(() => { if (o) return h(), () => g() }, [o, h, g]), p.jsx(st.ItemSlot, { scope: n, id: f, focusable: o, active: r, children: p.jsx(W.span, { tabIndex: l ? 0 : -1, "data-orientation": d.orientation, ...c, ref: t, onMouseDown: P(e.onMouseDown, w => { o ? d.onItemFocus(f) : w.preventDefault() }), onFocus: P(e.onFocus, () => d.onItemFocus(f)), onKeyDown: P(e.onKeyDown, w => { if (w.key === "Tab" && w.shiftKey) { d.onItemShiftTab(); return } if (w.target !== w.currentTarget) return; const x = ys(w, d.orientation, d.dir); if (x !== void 0) { if (w.metaKey || w.ctrlKey || w.altKey || w.shiftKey) return; w.preventDefault(); let b = m().filter(C => C.focusable).map(C => C.ref.current); if (x === "last") b.reverse(); else if (x === "prev" || x === "next") { x === "prev" && b.reverse(); const C = b.indexOf(w.currentTarget); b = d.loop ? bs(b, C + 1) : b.slice(C + 1) } setTimeout(() => Sn(b)) } }), children: typeof i == "function" ? i({ isCurrentTabStop: l, hasTabStop: v != null }) : i }) }) }); Mn.displayName = Rn; var xs = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" }; function vs(e, t) { return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e } function ys(e, t, n) { const o = vs(e.key, n); if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(o)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(o))) return xs[o] } function Sn(e, t = !1) { const n = document.activeElement; for (const o of e) if (o === n || (o.focus({ preventScroll: t }), document.activeElement !== n)) return } function bs(e, t) { return e.map((n, o) => e[(t + o) % e.length]) } var Cs = Cn, Rs = Mn; function Ms(e) { const t = Ss(e), n = a.forwardRef((o, r) => { const { children: s, ...i } = o, c = a.Children.toArray(s), u = c.find(_s); if (u) { const f = u.props.children, d = c.map(l => l === u ? a.Children.count(f) > 1 ? a.Children.only(null) : a.isValidElement(f) ? f.props.children : null : l); return p.jsx(t, { ...i, ref: r, children: a.isValidElement(f) ? a.cloneElement(f, void 0, d) : null }) } return p.jsx(t, { ...i, ref: r, children: s }) }); return n.displayName = `${e}.Slot`, n } function Ss(e) { const t = a.forwardRef((n, o) => { const { children: r, ...s } = n; if (a.isValidElement(r)) { const i = Ps(r), c = As(s, r.props); return r.type !== a.Fragment && (c.ref = o ? We(o, i) : i), a.cloneElement(r, c) } return a.Children.count(r) > 1 ? a.Children.only(null) : null }); return t.displayName = `${e}.SlotClone`, t } var Es = Symbol("radix.slottable"); function _s(e) { return a.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Es } function As(e, t) { const n = { ...t }; for (const o in t) { const r = e[o], s = t[o]; /^on[A-Z]/.test(o) ? r && s ? n[o] = (...c) => { const u = s(...c); return r(...c), u } : r && (n[o] = r) : o === "style" ? n[o] = { ...r, ...s } : o === "className" && (n[o] = [r, s].filter(Boolean).join(" ")) } return { ...e, ...n } } function Ps(e) { let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning; return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref) } var it = ["Enter", " "], Is = ["ArrowDown", "PageUp", "Home"], En = ["ArrowUp", "PageDown", "End"], Ds = [...Is, ...En], Os = { ltr: [...it, "ArrowRight"], rtl: [...it, "ArrowLeft"] }, Ts = { ltr: ["ArrowLeft"], rtl: ["ArrowRight"] }, Ae = "Menu", [Re, ks, Ns] = xn(Ae), [le, _n] = me(Ae, [Ns, ln, bn]), Ye = ln(), An = bn(), [js, ue] = le(Ae), [Ls, Pe] = le(Ae), Pn = e => { const { __scopeMenu: t, open: n = !1, children: o, dir: r, onOpenChange: s, modal: i = !0 } = e, c = Ye(t), [u, f] = a.useState(null), d = a.useRef(!1), l = Ge(s), m = vn(r); return a.useEffect(() => { const h = () => { d.current = !0, document.addEventListener("pointerdown", g, { capture: !0, once: !0 }), document.addEventListener("pointermove", g, { capture: !0, once: !0 }) }, g = () => d.current = !1; return document.addEventListener("keydown", h, { capture: !0 }), () => { document.removeEventListener("keydown", h, { capture: !0 }), document.removeEventListener("pointerdown", g, { capture: !0 }), document.removeEventListener("pointermove", g, { capture: !0 }) } }, []), p.jsx(ns, { ...c, children: p.jsx(js, { scope: t, open: n, onOpenChange: l, content: u, onContentChange: f, children: p.jsx(Ls, { scope: t, onClose: a.useCallback(() => l(!1), [l]), isUsingKeyboardRef: d, dir: m, modal: i, children: o }) }) }) }; Pn.displayName = Ae; var Fs = "MenuAnchor", wt = a.forwardRef((e, t) => { const { __scopeMenu: n, ...o } = e, r = Ye(n); return p.jsx(os, { ...r, ...o, ref: t }) }); wt.displayName = Fs; var xt = "MenuPortal", [$s, In] = le(xt, { forceMount: void 0 }), Dn = e => { const { __scopeMenu: t, forceMount: n, children: o, container: r } = e, s = ue(xt, t); return p.jsx($s, { scope: t, forceMount: n, children: p.jsx(Se, { present: n || s.open, children: p.jsx(po, { asChild: !0, container: r, children: o }) }) }) }; Dn.displayName = xt; var z = "MenuContent", [Bs, vt] = le(z), On = a.forwardRef((e, t) => { const n = In(z, e.__scopeMenu), { forceMount: o = n.forceMount, ...r } = e, s = ue(z, e.__scopeMenu), i = Pe(z, e.__scopeMenu); return p.jsx(Re.Provider, { scope: e.__scopeMenu, children: p.jsx(Se, { present: o || s.open, children: p.jsx(Re.Slot, { scope: e.__scopeMenu, children: i.modal ? p.jsx(Gs, { ...r, ref: t }) : p.jsx(Ws, { ...r, ref: t }) }) }) }) }), Gs = a.forwardRef((e, t) => { const n = ue(z, e.__scopeMenu), o = a.useRef(null), r = H(t, o); return a.useEffect(() => { const s = o.current; if (s) return mo(s) }, []), p.jsx(yt, { ...e, ref: r, trapFocus: n.open, disableOutsidePointerEvents: n.open, disableOutsideScroll: !0, onFocusOutside: P(e.onFocusOutside, s => s.preventDefault(), { checkForDefaultPrevented: !1 }), onDismiss: () => n.onOpenChange(!1) }) }), Ws = a.forwardRef((e, t) => { const n = ue(z, e.__scopeMenu); return p.jsx(yt, { ...e, ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, disableOutsideScroll: !1, onDismiss: () => n.onOpenChange(!1) }) }), Vs = Ms("MenuContent.ScrollLock"), yt = a.forwardRef((e, t) => { const { __scopeMenu: n, loop: o = !1, trapFocus: r, onOpenAutoFocus: s, onCloseAutoFocus: i, disableOutsidePointerEvents: c, onEntryFocus: u, onEscapeKeyDown: f, onPointerDownOutside: d, onFocusOutside: l, onInteractOutside: m, onDismiss: h, disableOutsideScroll: g, ...v } = e, w = ue(z, n), x = Pe(z, n), y = Ye(n), b = An(n), C = ks(n), [M, _] = a.useState(null), E = a.useRef(null), A = H(t, E, w.onContentChange), k = a.useRef(0), D = a.useRef(""), N = a.useRef(0), j = a.useRef(null), T = a.useRef("right"), O = a.useRef(0), $ = g ? go : a.Fragment, I = g ? { as: Vs, allowPinchZoom: !0 } : void 0, L = R => { const B = D.current + R, X = C().filter(F => !F.disabled), se = document.activeElement, we = X.find(F => F.ref.current === se)?.textValue, xe = X.map(F => F.textValue), Ie = ti(xe, B, we), ie = X.find(F => F.textValue === Ie)?.ref.current; (function F(ve) { D.current = ve, window.clearTimeout(k.current), ve !== "" && (k.current = window.setTimeout(() => F(""), 1e3)) })(B), ie && setTimeout(() => ie.focus()) }; a.useEffect(() => () => window.clearTimeout(k.current), []), ho(); const S = a.useCallback(R => T.current === j.current?.side && oi(R, j.current?.area), []); return p.jsx(Bs, { scope: n, searchRef: D, onItemEnter: a.useCallback(R => { S(R) && R.preventDefault() }, [S]), onItemLeave: a.useCallback(R => { S(R) || (E.current?.focus(), _(null)) }, [S]), onTriggerLeave: a.useCallback(R => { S(R) && R.preventDefault() }, [S]), pointerGraceTimerRef: N, onPointerGraceIntentChange: a.useCallback(R => { j.current = R }, []), children: p.jsx($, { ...I, children: p.jsx(wo, { asChild: !0, trapped: r, onMountAutoFocus: P(s, R => { R.preventDefault(), E.current?.focus({ preventScroll: !0 }) }), onUnmountAutoFocus: i, children: p.jsx(xo, { asChild: !0, disableOutsidePointerEvents: c, onEscapeKeyDown: f, onPointerDownOutside: d, onFocusOutside: l, onInteractOutside: m, onDismiss: h, children: p.jsx(Cs, { asChild: !0, ...b, dir: x.dir, orientation: "vertical", loop: o, currentTabStopId: M, onCurrentTabStopIdChange: _, onEntryFocus: P(u, R => { x.isUsingKeyboardRef.current || R.preventDefault() }), preventScrollOnEntryFocus: !0, children: p.jsx(rs, { role: "menu", "aria-orientation": "vertical", "data-state": Yn(w.open), "data-radix-menu-content": "", dir: x.dir, ...y, ...v, ref: A, style: { outline: "none", ...v.style }, onKeyDown: P(v.onKeyDown, R => { const X = R.target.closest("[data-radix-menu-content]") === R.currentTarget, se = R.ctrlKey || R.altKey || R.metaKey, we = R.key.length === 1; X && (R.key === "Tab" && R.preventDefault(), !se && we && L(R.key)); const xe = E.current; if (R.target !== xe || !Ds.includes(R.key)) return; R.preventDefault(); const ie = C().filter(F => !F.disabled).map(F => F.ref.current); En.includes(R.key) && ie.reverse(), Qs(ie) }), onBlur: P(e.onBlur, R => { R.currentTarget.contains(R.target) || (window.clearTimeout(k.current), D.current = "") }), onPointerMove: P(e.onPointerMove, Me(R => { const B = R.target, X = O.current !== R.clientX; if (R.currentTarget.contains(B) && X) { const se = R.clientX > O.current ? "right" : "left"; T.current = se, O.current = R.clientX } })) }) }) }) }) }) }) }); On.displayName = z; var Ks = "MenuGroup", bt = a.forwardRef((e, t) => { const { __scopeMenu: n, ...o } = e; return p.jsx(W.div, { role: "group", ...o, ref: t }) }); bt.displayName = Ks; var zs = "MenuLabel", Tn = a.forwardRef((e, t) => { const { __scopeMenu: n, ...o } = e; return p.jsx(W.div, { ...o, ref: t }) }); Tn.displayName = zs; var Fe = "MenuItem", jt = "menu.itemSelect", Xe = a.forwardRef((e, t) => { const { disabled: n = !1, onSelect: o, ...r } = e, s = a.useRef(null), i = Pe(Fe, e.__scopeMenu), c = vt(Fe, e.__scopeMenu), u = H(t, s), f = a.useRef(!1), d = () => { const l = s.current; if (!n && l) { const m = new CustomEvent(jt, { bubbles: !0, cancelable: !0 }); l.addEventListener(jt, h => o?.(h), { once: !0 }), vo(l, m), m.defaultPrevented ? f.current = !1 : i.onClose() } }; return p.jsx(kn, { ...r, ref: u, disabled: n, onClick: P(e.onClick, d), onPointerDown: l => { e.onPointerDown?.(l), f.current = !0 }, onPointerUp: P(e.onPointerUp, l => { f.current || l.currentTarget?.click() }), onKeyDown: P(e.onKeyDown, l => { const m = c.searchRef.current !== ""; n || m && l.key === " " || it.includes(l.key) && (l.currentTarget.click(), l.preventDefault()) }) }) }); Xe.displayName = Fe; var kn = a.forwardRef((e, t) => { const { __scopeMenu: n, disabled: o = !1, textValue: r, ...s } = e, i = vt(Fe, n), c = An(n), u = a.useRef(null), f = H(t, u), [d, l] = a.useState(!1), [m, h] = a.useState(""); return a.useEffect(() => { const g = u.current; g && h((g.textContent ?? "").trim()) }, [s.children]), p.jsx(Re.ItemSlot, { scope: n, disabled: o, textValue: r ?? m, children: p.jsx(Rs, { asChild: !0, ...c, focusable: !o, children: p.jsx(W.div, { role: "menuitem", "data-highlighted": d ? "" : void 0, "aria-disabled": o || void 0, "data-disabled": o ? "" : void 0, ...s, ref: f, onPointerMove: P(e.onPointerMove, Me(g => { o ? i.onItemLeave(g) : (i.onItemEnter(g), g.defaultPrevented || g.currentTarget.focus({ preventScroll: !0 })) })), onPointerLeave: P(e.onPointerLeave, Me(g => i.onItemLeave(g))), onFocus: P(e.onFocus, () => l(!0)), onBlur: P(e.onBlur, () => l(!1)) }) }) }) }), Hs = "MenuCheckboxItem", Nn = a.forwardRef((e, t) => { const { checked: n = !1, onCheckedChange: o, ...r } = e; return p.jsx(Bn, { scope: e.__scopeMenu, checked: n, children: p.jsx(Xe, { role: "menuitemcheckbox", "aria-checked": $e(n) ? "mixed" : n, ...r, ref: t, "data-state": Rt(n), onSelect: P(r.onSelect, () => o?.($e(n) ? !0 : !n), { checkForDefaultPrevented: !1 }) }) }) }); Nn.displayName = Hs; var jn = "MenuRadioGroup", [Us, Ys] = le(jn, { value: void 0, onValueChange: () => { } }), Ln = a.forwardRef((e, t) => { const { value: n, onValueChange: o, ...r } = e, s = Ge(o); return p.jsx(Us, { scope: e.__scopeMenu, value: n, onValueChange: s, children: p.jsx(bt, { ...r, ref: t }) }) }); Ln.displayName = jn; var Fn = "MenuRadioItem", $n = a.forwardRef((e, t) => { const { value: n, ...o } = e, r = Ys(Fn, e.__scopeMenu), s = n === r.value; return p.jsx(Bn, { scope: e.__scopeMenu, checked: s, children: p.jsx(Xe, { role: "menuitemradio", "aria-checked": s, ...o, ref: t, "data-state": Rt(s), onSelect: P(o.onSelect, () => r.onValueChange?.(n), { checkForDefaultPrevented: !1 }) }) }) }); $n.displayName = Fn; var Ct = "MenuItemIndicator", [Bn, Xs] = le(Ct, { checked: !1 }), Gn = a.forwardRef((e, t) => { const { __scopeMenu: n, forceMount: o, ...r } = e, s = Xs(Ct, n); return p.jsx(Se, { present: o || $e(s.checked) || s.checked === !0, children: p.jsx(W.span, { ...r, ref: t, "data-state": Rt(s.checked) }) }) }); Gn.displayName = Ct; var qs = "MenuSeparator", Wn = a.forwardRef((e, t) => { const { __scopeMenu: n, ...o } = e; return p.jsx(W.div, { role: "separator", "aria-orientation": "horizontal", ...o, ref: t }) }); Wn.displayName = qs; var Zs = "MenuArrow", Vn = a.forwardRef((e, t) => { const { __scopeMenu: n, ...o } = e, r = Ye(n); return p.jsx(ss, { ...r, ...o, ref: t }) }); Vn.displayName = Zs; var Js = "MenuSub", [rc, Kn] = le(Js), ye = "MenuSubTrigger", zn = a.forwardRef((e, t) => { const n = ue(ye, e.__scopeMenu), o = Pe(ye, e.__scopeMenu), r = Kn(ye, e.__scopeMenu), s = vt(ye, e.__scopeMenu), i = a.useRef(null), { pointerGraceTimerRef: c, onPointerGraceIntentChange: u } = s, f = { __scopeMenu: e.__scopeMenu }, d = a.useCallback(() => { i.current && window.clearTimeout(i.current), i.current = null }, []); return a.useEffect(() => d, [d]), a.useEffect(() => { const l = c.current; return () => { window.clearTimeout(l), u(null) } }, [c, u]), p.jsx(wt, { asChild: !0, ...f, children: p.jsx(kn, { id: r.triggerId, "aria-haspopup": "menu", "aria-expanded": n.open, "aria-controls": r.contentId, "data-state": Yn(n.open), ...e, ref: We(t, r.onTriggerChange), onClick: l => { e.onClick?.(l), !(e.disabled || l.defaultPrevented) && (l.currentTarget.focus(), n.open || n.onOpenChange(!0)) }, onPointerMove: P(e.onPointerMove, Me(l => { s.onItemEnter(l), !l.defaultPrevented && !e.disabled && !n.open && !i.current && (s.onPointerGraceIntentChange(null), i.current = window.setTimeout(() => { n.onOpenChange(!0), d() }, 100)) })), onPointerLeave: P(e.onPointerLeave, Me(l => { d(); const m = n.content?.getBoundingClientRect(); if (m) { const h = n.content?.dataset.side, g = h === "right", v = g ? -5 : 5, w = m[g ? "left" : "right"], x = m[g ? "right" : "left"]; s.onPointerGraceIntentChange({ area: [{ x: l.clientX + v, y: l.clientY }, { x: w, y: m.top }, { x, y: m.top }, { x, y: m.bottom }, { x: w, y: m.bottom }], side: h }), window.clearTimeout(c.current), c.current = window.setTimeout(() => s.onPointerGraceIntentChange(null), 300) } else { if (s.onTriggerLeave(l), l.defaultPrevented) return; s.onPointerGraceIntentChange(null) } })), onKeyDown: P(e.onKeyDown, l => { const m = s.searchRef.current !== ""; e.disabled || m && l.key === " " || Os[o.dir].includes(l.key) && (n.onOpenChange(!0), n.content?.focus(), l.preventDefault()) }) }) }) }); zn.displayName = ye; var Hn = "MenuSubContent", Un = a.forwardRef((e, t) => { const n = In(z, e.__scopeMenu), { forceMount: o = n.forceMount, ...r } = e, s = ue(z, e.__scopeMenu), i = Pe(z, e.__scopeMenu), c = Kn(Hn, e.__scopeMenu), u = a.useRef(null), f = H(t, u); return p.jsx(Re.Provider, { scope: e.__scopeMenu, children: p.jsx(Se, { present: o || s.open, children: p.jsx(Re.Slot, { scope: e.__scopeMenu, children: p.jsx(yt, { id: c.contentId, "aria-labelledby": c.triggerId, ...r, ref: f, align: "start", side: i.dir === "rtl" ? "left" : "right", disableOutsidePointerEvents: !1, disableOutsideScroll: !1, trapFocus: !1, onOpenAutoFocus: d => { i.isUsingKeyboardRef.current && u.current?.focus(), d.preventDefault() }, onCloseAutoFocus: d => d.preventDefault(), onFocusOutside: P(e.onFocusOutside, d => { d.target !== c.trigger && s.onOpenChange(!1) }), onEscapeKeyDown: P(e.onEscapeKeyDown, d => { i.onClose(), d.preventDefault() }), onKeyDown: P(e.onKeyDown, d => { const l = d.currentTarget.contains(d.target), m = Ts[i.dir].includes(d.key); l && m && (s.onOpenChange(!1), c.trigger?.focus(), d.preventDefault()) }) }) }) }) }) }); Un.displayName = Hn; function Yn(e) { return e ? "open" : "closed" } function $e(e) { return e === "indeterminate" } function Rt(e) { return $e(e) ? "indeterminate" : e ? "checked" : "unchecked" } function Qs(e) { const t = document.activeElement; for (const n of e) if (n === t || (n.focus(), document.activeElement !== t)) return } function ei(e, t) { return e.map((n, o) => e[(t + o) % e.length]) } function ti(e, t, n) { const r = t.length > 1 && Array.from(t).every(f => f === t[0]) ? t[0] : t, s = n ? e.indexOf(n) : -1; let i = ei(e, Math.max(s, 0)); r.length === 1 && (i = i.filter(f => f !== n)); const u = i.find(f => f.toLowerCase().startsWith(r.toLowerCase())); return u !== n ? u : void 0 } function ni(e, t) { const { x: n, y: o } = e; let r = !1; for (let s = 0, i = t.length - 1; s < t.length; i = s++) { const c = t[s], u = t[i], f = c.x, d = c.y, l = u.x, m = u.y; d > o != m > o && n < (l - f) * (o - d) / (m - d) + f && (r = !r) } return r } function oi(e, t) { if (!t) return !1; const n = { x: e.clientX, y: e.clientY }; return ni(n, t) } function Me(e) { return t => t.pointerType === "mouse" ? e(t) : void 0 } var ri = Pn, si = wt, ii = Dn, ci = On, ai = bt, li = Tn, ui = Xe, di = Nn, fi = Ln, pi = $n, mi = Gn, hi = Wn, gi = Vn, wi = zn, xi = Un, qe = "DropdownMenu", [vi] = me(qe, [_n]), G = _n(), [yi, Xn] = vi(qe), qn = e => { const { __scopeDropdownMenu: t, children: n, dir: o, open: r, defaultOpen: s, onOpenChange: i, modal: c = !0 } = e, u = G(t), f = a.useRef(null), [d, l] = ct({ prop: r, defaultProp: s ?? !1, onChange: i, caller: qe }); return p.jsx(yi, { scope: t, triggerId: tt(), triggerRef: f, contentId: tt(), open: d, onOpenChange: l, onOpenToggle: a.useCallback(() => l(m => !m), [l]), modal: c, children: p.jsx(ri, { ...u, open: d, onOpenChange: l, dir: o, modal: c, children: n }) }) }; qn.displayName = qe; var Zn = "DropdownMenuTrigger", Jn = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, disabled: o = !1, ...r } = e, s = Xn(Zn, n), i = G(n); return p.jsx(si, { asChild: !0, ...i, children: p.jsx(W.button, { type: "button", id: s.triggerId, "aria-haspopup": "menu", "aria-expanded": s.open, "aria-controls": s.open ? s.contentId : void 0, "data-state": s.open ? "open" : "closed", "data-disabled": o ? "" : void 0, disabled: o, ...r, ref: We(t, s.triggerRef), onPointerDown: P(e.onPointerDown, c => { !o && c.button === 0 && c.ctrlKey === !1 && (s.onOpenToggle(), s.open || c.preventDefault()) }), onKeyDown: P(e.onKeyDown, c => { o || (["Enter", " "].includes(c.key) && s.onOpenToggle(), c.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(c.key) && c.preventDefault()) }) }) }) }); Jn.displayName = Zn; var bi = "DropdownMenuPortal", Qn = e => { const { __scopeDropdownMenu: t, ...n } = e, o = G(t); return p.jsx(ii, { ...o, ...n }) }; Qn.displayName = bi; var eo = "DropdownMenuContent", to = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = Xn(eo, n), s = G(n), i = a.useRef(!1); return p.jsx(ci, { id: r.contentId, "aria-labelledby": r.triggerId, ...s, ...o, ref: t, onCloseAutoFocus: P(e.onCloseAutoFocus, c => { i.current || r.triggerRef.current?.focus(), i.current = !1, c.preventDefault() }), onInteractOutside: P(e.onInteractOutside, c => { const u = c.detail.originalEvent, f = u.button === 0 && u.ctrlKey === !0, d = u.button === 2 || f; (!r.modal || d) && (i.current = !0) }), style: { ...e.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" } }) }); to.displayName = eo; var Ci = "DropdownMenuGroup", Ri = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(ai, { ...r, ...o, ref: t }) }); Ri.displayName = Ci; var Mi = "DropdownMenuLabel", Si = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(li, { ...r, ...o, ref: t }) }); Si.displayName = Mi; var Ei = "DropdownMenuItem", _i = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(ui, { ...r, ...o, ref: t }) }); _i.displayName = Ei; var Ai = "DropdownMenuCheckboxItem", Pi = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(di, { ...r, ...o, ref: t }) }); Pi.displayName = Ai; var Ii = "DropdownMenuRadioGroup", no = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(fi, { ...r, ...o, ref: t }) }); no.displayName = Ii; var Di = "DropdownMenuRadioItem", oo = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(pi, { ...r, ...o, ref: t }) }); oo.displayName = Di; var Oi = "DropdownMenuItemIndicator", ro = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(mi, { ...r, ...o, ref: t }) }); ro.displayName = Oi; var Ti = "DropdownMenuSeparator", ki = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(hi, { ...r, ...o, ref: t }) }); ki.displayName = Ti; var Ni = "DropdownMenuArrow", ji = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(gi, { ...r, ...o, ref: t }) }); ji.displayName = Ni; var Li = "DropdownMenuSubTrigger", Fi = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(wi, { ...r, ...o, ref: t }) }); Fi.displayName = Li; var $i = "DropdownMenuSubContent", Bi = a.forwardRef((e, t) => { const { __scopeDropdownMenu: n, ...o } = e, r = G(n); return p.jsx(xi, { ...r, ...o, ref: t, style: { ...e.style, "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)", "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)", "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)", "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)" } }) }); Bi.displayName = $i; var Gi = qn, Wi = Jn, Vi = Qn, Ki = to, zi = no, Hi = oo, Ui = ro; function Yi({ ...e }) { return p.jsx(Gi, { "data-slot": "dropdown-menu", ...e }) } function Xi({ ...e }) { return p.jsx(Wi, { "data-slot": "dropdown-menu-trigger", ...e }) } function qi({ className: e, sideOffset: t = 4, ...n }) { return p.jsx(Vi, { children: p.jsx(Ki, { "data-slot": "dropdown-menu-content", sideOffset: t, className: fe("data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=closed]:animate-out data-[state=open]:animate-in", e), ...n }) }) } function Zi({ ...e }) { return p.jsx(zi, { "data-slot": "dropdown-menu-radio-group", ...e }) } function Ji({ className: e, children: t, ...n }) { return p.jsxs(Hi, { "data-slot": "dropdown-menu-radio-item", className: fe("relative flex cursor-default select-none items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg:not([class*='size-'])]:size-4 [&_svg]:pointer-events-none [&_svg]:shrink-0", e), ...n, children: [p.jsx("span", { className: "pointer-events-none absolute left-2 flex size-3.5 items-center justify-center", children: p.jsx(Ui, { children: p.jsx(Mo, { className: "size-2 fill-current" }) }) }), t] }) } const Lt = [{ value: "system", icon: Ft, label: "System" }, { value: "light", icon: Ao, label: "Light" }, { value: "dark", icon: Eo, label: "Dark" }], sc = ({ hideLabel: e = !0, iconClassName: t, className: n }) => { const { theme: o, setTheme: r } = yo(), s = Lt.find(c => c.value === o), i = s?.icon || Ft; return p.jsxs(Yi, { children: [p.jsx(Xi, { asChild: !0, children: p.jsxs(bo, { variant: "ghost", size: e ? "icon" : "default", "aria-label": `Current theme: ${s?.label}`, className: fe(n), children: [p.jsx(i, { className: fe("h-5 w-5", t) }), !e && p.jsx("span", { children: s?.label || "Theme" })] }) }), p.jsx(qi, { align: "end", children: p.jsx(Zi, { value: o, onValueChange: c => r(c), children: Lt.map(({ value: c, icon: u, label: f }) => p.jsxs(Ji, { value: c, children: [p.jsx(u, { className: "h-4 w-4" }), p.jsx("span", { children: f })] }, c)) }) })] }) }; export { os as A, ec as B, rs as C, oc as L, ns as R, sc as T, tc as _, ss as a, nc as b, ln as c, xn as d, Po as e, $t as f, vn as u };
