import{_ as w,aw as Y,ax as j,ay as F,az as H,l as s,c as V,aA as z,aB as U,ag as $,al as q,ah as P,af as K,aC as Q,aD as W,aE as Z}from"./mermaid.core-CkHIMxP5.js";import{G as T}from"./graph-db47vGp_.js";import{l as I}from"./layout-BA3PnBRE.js";import{i as N}from"./_baseUniq-5DndRzKp.js";import{c as L}from"./clone-DoV_5dO0.js";import{m as A}from"./_basePickBy-i9cN_cnC.js";import"./sidepanel-B3oUqyzD.js";import"./product_logo-C96HwpIU.js";import"./compact-ChNK-LcA.js";import"./theme-toggle-DsZTZK7_.js";import"./proxy-DPK92tJS.js";import"./useBrowserOSProviders-BLKu1s2X.js";import"./settings-De2ErBO4.js";import"./productUrls-C-nvukbD.js";(function(){try{var e=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{};e.SENTRY_RELEASE={id:"384410028dc6aac75eb61d6b08dc7127d516d4af"}}catch{}})();try{(function(){var e=typeof window<"u"?window:typeof global<"u"?global:typeof globalThis<"u"?globalThis:typeof self<"u"?self:{},t=new e.Error().stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="137e9b96-62dc-4136-9c15-4cda355e8348",e._sentryDebugIdIdentifier="sentry-dbid-137e9b96-62dc-4136-9c15-4cda355e8348")})()}catch{}function h(e){var t={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return N(e.graph())||(t.value=L(e.graph())),t}function ee(e){return A(e.nodes(),function(t){var n=e.node(t),a=e.parent(t),r={v:t};return N(n)||(r.value=n),N(a)||(r.parent=a),r})}function ne(e){return A(e.edges(),function(t){var n=e.edge(t),a={v:t.v,w:t.w};return N(t.name)||(a.name=t.name),N(n)||(a.value=n),a})}var d=new Map,v=new Map,B=new Map,te=w(()=>{v.clear(),B.clear(),d.clear()},"clear"),D=w((e,t)=>{const n=v.get(t)||[];return s.trace("In isDescendant",t," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),ie=w((e,t)=>{const n=v.get(t)||[];return s.info("Descendants of ",t," is ",n),s.info("Edge is ",e),e.v===t||e.w===t?!1:n?n.includes(e.v)||D(e.v,t)||D(e.w,t)||n.includes(e.w):(s.debug("Tilt, ",t,",not in descendants"),!1)},"edgeInCluster"),R=w((e,t,n,a)=>{s.warn("Copying children of ",e,"root",a,"data",t.node(e),a);const r=t.children(e)||[];e!==a&&r.push(e),s.warn("Copying (nodes) clusterId",e,"nodes",r),r.forEach(o=>{if(t.children(o).length>0)R(o,t,n,a);else{const l=t.node(o);s.info("cp ",o," to ",a," with parent ",e),n.setNode(o,l),a!==t.parent(o)&&(s.warn("Setting parent",o,t.parent(o)),n.setParent(o,t.parent(o))),e!==a&&o!==e?(s.debug("Setting parent",o,e),n.setParent(o,e)):(s.info("In copy ",e,"root",a,"data",t.node(e),a),s.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==a,"node!==clusterId",o!==e));const u=t.edges(o);s.debug("Copying Edges",u),u.forEach(c=>{s.info("Edge",c);const m=t.edge(c.v,c.w,c.name);s.info("Edge data",m,a);try{ie(c,a)?(s.info("Copying as ",c.v,c.w,m,c.name),n.setEdge(c.v,c.w,m,c.name),s.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):s.info("Skipping copy of edge ",c.v,"-->",c.w," rootId: ",a," clusterId:",e)}catch(p){s.error(p)}})}s.debug("Removing node",o),t.removeNode(o)})},"copy"),J=w((e,t)=>{const n=t.children(e);let a=[...n];for(const r of n)B.set(r,e),a=[...a,...J(r,t)];return a},"extractDescendants"),se=w((e,t,n)=>{const a=e.edges().filter(c=>c.v===t||c.w===t),r=e.edges().filter(c=>c.v===n||c.w===n),o=a.map(c=>({v:c.v===t?n:c.v,w:c.w===t?t:c.w})),l=r.map(c=>({v:c.v,w:c.w}));return o.filter(c=>l.some(m=>c.v===m.v&&c.w===m.w))},"findCommonEdges"),C=w((e,t,n)=>{const a=t.children(e);if(s.trace("Searching children of id ",e,a),a.length<1)return e;let r;for(const o of a){const l=C(o,t,n),u=se(t,n,l);if(l)if(u.length>0)r=l;else return l}return r},"findNonClusterChild"),k=w(e=>!d.has(e)||!d.get(e).externalConnections?e:d.has(e)?d.get(e).id:e,"getAnchorId"),re=w((e,t)=>{if(!e||t>10){s.debug("Opting out, no graph ");return}else s.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(s.warn("Cluster identified",n," Replacement id in edges: ",C(n,e,n)),v.set(n,J(n,e)),d.set(n,{id:C(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){const a=e.children(n),r=e.edges();a.length>0?(s.debug("Cluster identified",n,v),r.forEach(o=>{const l=D(o.v,n),u=D(o.w,n);l^u&&(s.warn("Edge: ",o," leaves cluster ",n),s.warn("Descendants of XXX ",n,": ",v.get(n)),d.get(n).externalConnections=!0)})):s.debug("Not a cluster ",n,v)});for(let n of d.keys()){const a=d.get(n).id,r=e.parent(a);r!==n&&d.has(r)&&!d.get(r).externalConnections&&(d.get(n).id=r)}e.edges().forEach(function(n){const a=e.edge(n);s.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),s.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let r=n.v,o=n.w;if(s.warn("Fix XXX",d,"ids:",n.v,n.w,"Translating: ",d.get(n.v)," --- ",d.get(n.w)),d.get(n.v)||d.get(n.w)){if(s.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),r=k(n.v),o=k(n.w),e.removeEdge(n.v,n.w,n.name),r!==n.v){const l=e.parent(r);d.get(l).externalConnections=!0,a.fromCluster=n.v}if(o!==n.w){const l=e.parent(o);d.get(l).externalConnections=!0,a.toCluster=n.w}s.warn("Fix Replacing with XXX",r,o,n.name),e.setEdge(r,o,a,n.name)}}),s.warn("Adjusted Graph",h(e)),G(e,0),s.trace(d)},"adjustClustersAndEdges"),G=w((e,t)=>{if(s.warn("extractor - ",t,h(e),e.children("D")),t>10){s.error("Bailing out");return}let n=e.nodes(),a=!1;for(const r of n){const o=e.children(r);a=a||o.length>0}if(!a){s.debug("Done, no node has children",e.nodes());return}s.debug("Nodes = ",n,t);for(const r of n)if(s.debug("Extracting node",r,d,d.has(r)&&!d.get(r).externalConnections,!e.parent(r),e.node(r),e.children("D")," Depth ",t),!d.has(r))s.debug("Not a cluster",r,t);else if(!d.get(r).externalConnections&&e.children(r)&&e.children(r).length>0){s.warn("Cluster without external connections, without a parent and with children",r,t);let l=e.graph().rankdir==="TB"?"LR":"TB";d.get(r)?.clusterData?.dir&&(l=d.get(r).clusterData.dir,s.warn("Fixing dir",d.get(r).clusterData.dir,l));const u=new T({multigraph:!0,compound:!0}).setGraph({rankdir:l,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});s.warn("Old graph before copy",h(e)),R(r,e,u,r),e.setNode(r,{clusterNode:!0,id:r,clusterData:d.get(r).clusterData,label:d.get(r).label,graph:u}),s.warn("New graph after copy node: (",r,")",h(u)),s.debug("Old graph after copy",h(e))}else s.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!d.get(r).externalConnections," no parent: ",!e.parent(r)," children ",e.children(r)&&e.children(r).length>0,e.children("D"),t),s.debug(d);n=e.nodes(),s.warn("New list of nodes",n);for(const r of n){const o=e.node(r);s.warn(" Now next level",r,o),o?.clusterNode&&G(o.graph,t+1)}},"extractor"),_=w((e,t)=>{if(t.length===0)return[];let n=Object.assign([],t);return t.forEach(a=>{const r=e.children(a),o=_(e,r);n=[...n,...o]}),n},"sorter"),oe=w(e=>_(e,e.children()),"sortNodesByHierarchy"),M=w(async(e,t,n,a,r,o)=>{s.warn("Graph in recursive render:XAX",h(t),r);const l=t.graph().rankdir;s.trace("Dir in recursive render - dir:",l);const u=e.insert("g").attr("class","root");t.nodes()?s.info("Recursive render XXX",t.nodes()):s.info("No nodes found for",t),t.edges().length>0&&s.info("Recursive edges",t.edge(t.edges()[0]));const c=u.insert("g").attr("class","clusters"),m=u.insert("g").attr("class","edgePaths"),p=u.insert("g").attr("class","edgeLabels"),y=u.insert("g").attr("class","nodes");await Promise.all(t.nodes().map(async function(f){const i=t.node(f);if(r!==void 0){const g=JSON.parse(JSON.stringify(r.clusterData));s.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,g.height,`
Parent cluster`,r.height),t.setNode(r.id,g),t.parent(f)||(s.trace("Setting parent",f,r.id),t.setParent(f,r.id,g))}if(s.info("(Insert) Node XXX"+f+": "+JSON.stringify(t.node(f))),i?.clusterNode){s.info("Cluster identified XBX",f,i.width,t.node(f));const{ranksep:g,nodesep:E}=t.graph();i.graph.setGraph({...i.graph.graph(),ranksep:g+25,nodesep:E});const X=await M(y,i.graph,n,a,t.node(f),o),x=X.elem;z(i,x),i.diff=X.diff||0,s.info("New compound node after recursive render XAX",f,"width",i.width,"height",i.height),U(x,i)}else t.children(f).length>0?(s.trace("Cluster - the non recursive path XBX",f,i.id,i,i.width,"Graph:",t),s.trace(C(i.id,t)),d.set(i.id,{id:C(i.id,t),node:i})):(s.trace("Node - the non recursive path XAX",f,y,t.node(f),l),await $(y,t.node(f),{config:o,dir:l}))})),await w(async()=>{const f=t.edges().map(async function(i){const g=t.edge(i.v,i.w,i.name);s.info("Edge "+i.v+" -> "+i.w+": "+JSON.stringify(i)),s.info("Edge "+i.v+" -> "+i.w+": ",i," ",JSON.stringify(t.edge(i))),s.info("Fix",d,"ids:",i.v,i.w,"Translating: ",d.get(i.v),d.get(i.w)),await Z(p,g)});await Promise.all(f)},"processEdges")(),s.info("Graph before layout:",JSON.stringify(h(t))),s.info("############################################# XXX"),s.info("###                Layout                 ### XXX"),s.info("############################################# XXX"),I(t),s.info("Graph after layout:",JSON.stringify(h(t)));let O=0,{subGraphTitleTotalMargin:S}=q(o);return await Promise.all(oe(t).map(async function(f){const i=t.node(f);if(s.info("Position XBX => "+f+": ("+i.x,","+i.y,") width: ",i.width," height: ",i.height),i?.clusterNode)i.y+=S,s.info("A tainted cluster node XBX1",f,i.id,i.width,i.height,i.x,i.y,t.parent(f)),d.get(i.id).node=i,P(i);else if(t.children(f).length>0){s.info("A pure cluster node XBX1",f,i.id,i.x,i.y,i.width,i.height,t.parent(f)),i.height+=S,t.node(i.parentId);const g=i?.padding/2||0,E=i?.labelBBox?.height||0,X=E-g||0;s.debug("OffsetY",X,"labelHeight",E,"halfPadding",g),await K(c,i),d.get(i.id).node=i}else{const g=t.node(i.parentId);i.y+=S/2,s.info("A regular node XBX1 - using the padding",i.id,"parent",i.parentId,i.width,i.height,i.x,i.y,"offsetY",i.offsetY,"parent",g,g?.offsetY,i),P(i)}})),t.edges().forEach(function(f){const i=t.edge(f);s.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(i),i),i.points.forEach(x=>x.y+=S/2);const g=t.node(f.v);var E=t.node(f.w);const X=Q(m,i,d,n,g,E,a);W(i,X)}),t.nodes().forEach(function(f){const i=t.node(f);s.info(f,i.type,i.diff),i.isGroup&&(O=i.diff)}),s.warn("Returning from recursive render XAX",u,O),{elem:u,diff:O}},"recursiveRender"),Ee=w(async(e,t)=>{const n=new T({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),a=t.select("g");Y(a,e.markers,e.type,e.diagramId),j(),F(),H(),te(),e.nodes.forEach(o=>{n.setNode(o.id,{...o}),o.parentId&&n.setParent(o.id,o.parentId)}),s.debug("Edges:",e.edges),e.edges.forEach(o=>{if(o.start===o.end){const l=o.start,u=l+"---"+l+"---1",c=l+"---"+l+"---2",m=n.node(l);n.setNode(u,{domId:u,id:u,parentId:m.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(u,m.parentId),n.setNode(c,{domId:c,id:c,parentId:m.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(c,m.parentId);const p=structuredClone(o),y=structuredClone(o),b=structuredClone(o);p.label="",p.arrowTypeEnd="none",p.id=l+"-cyclic-special-1",y.arrowTypeStart="none",y.arrowTypeEnd="none",y.id=l+"-cyclic-special-mid",b.label="",m.isGroup&&(p.fromCluster=l,b.toCluster=l),b.id=l+"-cyclic-special-2",b.arrowTypeStart="none",n.setEdge(l,u,p,l+"-cyclic-special-0"),n.setEdge(u,c,y,l+"-cyclic-special-1"),n.setEdge(c,l,b,l+"-cyc<lic-special-2")}else n.setEdge(o.start,o.end,{...o},o.id)}),s.warn("Graph at first:",JSON.stringify(h(n))),re(n),s.warn("Graph after XAX:",JSON.stringify(h(n)));const r=V();await M(a,n,e.type,e.diagramId,void 0,r)},"render");export{Ee as render};
