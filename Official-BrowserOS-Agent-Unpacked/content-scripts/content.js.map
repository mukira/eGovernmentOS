{"version":3,"file":"content.js","sources":["../../../node_modules/wxt/dist/utils/define-content-script.mjs","../../../entrypoints/content.ts","../../../node_modules/wxt/dist/browser.mjs","../../../node_modules/@wxt-dev/browser/src/index.mjs","../../../node_modules/wxt/dist/utils/internal/logger.mjs","../../../node_modules/wxt/dist/utils/internal/custom-events.mjs","../../../node_modules/wxt/dist/utils/internal/location-watcher.mjs","../../../node_modules/wxt/dist/utils/content-script-context.mjs"],"sourcesContent":["export function defineContentScript(definition) {\n  return definition;\n}\n","export default defineContentScript({\n  matches: ['*://*.google.com/*'],\n  main() {},\n})\n","import { browser as _browser } from \"@wxt-dev/browser\";\nexport const browser = _browser;\nexport {};\n","// #region snippet\nexport const browser = globalThis.browser?.runtime?.id\n  ? globalThis.browser\n  : globalThis.chrome;\n// #endregion snippet\n","function print(method, ...args) {\n  if (import.meta.env.MODE === \"production\") return;\n  if (typeof args[0] === \"string\") {\n    const message = args.shift();\n    method(`[wxt] ${message}`, ...args);\n  } else {\n    method(\"[wxt]\", ...args);\n  }\n}\nexport const logger = {\n  debug: (...args) => print(console.debug, ...args),\n  log: (...args) => print(console.log, ...args),\n  warn: (...args) => print(console.warn, ...args),\n  error: (...args) => print(console.error, ...args)\n};\n","import { browser } from \"wxt/browser\";\nexport class WxtLocationChangeEvent extends Event {\n  constructor(newUrl, oldUrl) {\n    super(WxtLocationChangeEvent.EVENT_NAME, {});\n    this.newUrl = newUrl;\n    this.oldUrl = oldUrl;\n  }\n  static EVENT_NAME = getUniqueEventName(\"wxt:locationchange\");\n}\nexport function getUniqueEventName(eventName) {\n  return `${browser?.runtime?.id}:${import.meta.env.ENTRYPOINT}:${eventName}`;\n}\n","import { WxtLocationChangeEvent } from \"./custom-events.mjs\";\nexport function createLocationWatcher(ctx) {\n  let interval;\n  let oldUrl;\n  return {\n    /**\n     * Ensure the location watcher is actively looking for URL changes. If it's already watching,\n     * this is a noop.\n     */\n    run() {\n      if (interval != null) return;\n      oldUrl = new URL(location.href);\n      interval = ctx.setInterval(() => {\n        let newUrl = new URL(location.href);\n        if (newUrl.href !== oldUrl.href) {\n          window.dispatchEvent(new WxtLocationChangeEvent(newUrl, oldUrl));\n          oldUrl = newUrl;\n        }\n      }, 1e3);\n    }\n  };\n}\n","import { browser } from \"wxt/browser\";\nimport { logger } from \"../utils/internal/logger.mjs\";\nimport {\n  getUniqueEventName\n} from \"./internal/custom-events.mjs\";\nimport { createLocationWatcher } from \"./internal/location-watcher.mjs\";\nexport class ContentScriptContext {\n  constructor(contentScriptName, options) {\n    this.contentScriptName = contentScriptName;\n    this.options = options;\n    this.abortController = new AbortController();\n    if (this.isTopFrame) {\n      this.listenForNewerScripts({ ignoreFirstEvent: true });\n      this.stopOldScripts();\n    } else {\n      this.listenForNewerScripts();\n    }\n  }\n  static SCRIPT_STARTED_MESSAGE_TYPE = getUniqueEventName(\n    \"wxt:content-script-started\"\n  );\n  isTopFrame = window.self === window.top;\n  abortController;\n  locationWatcher = createLocationWatcher(this);\n  receivedMessageIds = /* @__PURE__ */ new Set();\n  get signal() {\n    return this.abortController.signal;\n  }\n  abort(reason) {\n    return this.abortController.abort(reason);\n  }\n  get isInvalid() {\n    if (browser.runtime.id == null) {\n      this.notifyInvalidated();\n    }\n    return this.signal.aborted;\n  }\n  get isValid() {\n    return !this.isInvalid;\n  }\n  /**\n   * Add a listener that is called when the content script's context is invalidated.\n   *\n   * @returns A function to remove the listener.\n   *\n   * @example\n   * browser.runtime.onMessage.addListener(cb);\n   * const removeInvalidatedListener = ctx.onInvalidated(() => {\n   *   browser.runtime.onMessage.removeListener(cb);\n   * })\n   * // ...\n   * removeInvalidatedListener();\n   */\n  onInvalidated(cb) {\n    this.signal.addEventListener(\"abort\", cb);\n    return () => this.signal.removeEventListener(\"abort\", cb);\n  }\n  /**\n   * Return a promise that never resolves. Useful if you have an async function that shouldn't run\n   * after the context is expired.\n   *\n   * @example\n   * const getValueFromStorage = async () => {\n   *   if (ctx.isInvalid) return ctx.block();\n   *\n   *   // ...\n   * }\n   */\n  block() {\n    return new Promise(() => {\n    });\n  }\n  /**\n   * Wrapper around `window.setInterval` that automatically clears the interval when invalidated.\n   *\n   * Intervals can be cleared by calling the normal `clearInterval` function.\n   */\n  setInterval(handler, timeout) {\n    const id = setInterval(() => {\n      if (this.isValid) handler();\n    }, timeout);\n    this.onInvalidated(() => clearInterval(id));\n    return id;\n  }\n  /**\n   * Wrapper around `window.setTimeout` that automatically clears the interval when invalidated.\n   *\n   * Timeouts can be cleared by calling the normal `setTimeout` function.\n   */\n  setTimeout(handler, timeout) {\n    const id = setTimeout(() => {\n      if (this.isValid) handler();\n    }, timeout);\n    this.onInvalidated(() => clearTimeout(id));\n    return id;\n  }\n  /**\n   * Wrapper around `window.requestAnimationFrame` that automatically cancels the request when\n   * invalidated.\n   *\n   * Callbacks can be canceled by calling the normal `cancelAnimationFrame` function.\n   */\n  requestAnimationFrame(callback) {\n    const id = requestAnimationFrame((...args) => {\n      if (this.isValid) callback(...args);\n    });\n    this.onInvalidated(() => cancelAnimationFrame(id));\n    return id;\n  }\n  /**\n   * Wrapper around `window.requestIdleCallback` that automatically cancels the request when\n   * invalidated.\n   *\n   * Callbacks can be canceled by calling the normal `cancelIdleCallback` function.\n   */\n  requestIdleCallback(callback, options) {\n    const id = requestIdleCallback((...args) => {\n      if (!this.signal.aborted) callback(...args);\n    }, options);\n    this.onInvalidated(() => cancelIdleCallback(id));\n    return id;\n  }\n  addEventListener(target, type, handler, options) {\n    if (type === \"wxt:locationchange\") {\n      if (this.isValid) this.locationWatcher.run();\n    }\n    target.addEventListener?.(\n      type.startsWith(\"wxt:\") ? getUniqueEventName(type) : type,\n      handler,\n      {\n        ...options,\n        signal: this.signal\n      }\n    );\n  }\n  /**\n   * @internal\n   * Abort the abort controller and execute all `onInvalidated` listeners.\n   */\n  notifyInvalidated() {\n    this.abort(\"Content script context invalidated\");\n    logger.debug(\n      `Content script \"${this.contentScriptName}\" context invalidated`\n    );\n  }\n  stopOldScripts() {\n    window.postMessage(\n      {\n        type: ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE,\n        contentScriptName: this.contentScriptName,\n        messageId: Math.random().toString(36).slice(2)\n      },\n      \"*\"\n    );\n  }\n  verifyScriptStartedEvent(event) {\n    const isScriptStartedEvent = event.data?.type === ContentScriptContext.SCRIPT_STARTED_MESSAGE_TYPE;\n    const isSameContentScript = event.data?.contentScriptName === this.contentScriptName;\n    const isNotDuplicate = !this.receivedMessageIds.has(event.data?.messageId);\n    return isScriptStartedEvent && isSameContentScript && isNotDuplicate;\n  }\n  listenForNewerScripts(options) {\n    let isFirst = true;\n    const cb = (event) => {\n      if (this.verifyScriptStartedEvent(event)) {\n        this.receivedMessageIds.add(event.data.messageId);\n        const wasFirst = isFirst;\n        isFirst = false;\n        if (wasFirst && options?.ignoreFirstEvent) return;\n        this.notifyInvalidated();\n      }\n    };\n    addEventListener(\"message\", cb);\n    this.onInvalidated(() => removeEventListener(\"message\", cb));\n  }\n}\n"],"names":["defineContentScript","definition","browser","print","method","args","logger","WxtLocationChangeEvent","newUrl","oldUrl","getUniqueEventName","eventName","createLocationWatcher","ctx","interval","ContentScriptContext","contentScriptName","options","reason","cb","handler","timeout","id","callback","target","type","event","isScriptStartedEvent","isSameContentScript","isNotDuplicate","isFirst","wasFirst"],"mappings":"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","x_google_ignoreList":[0,2,3,4,5,6,7]}